# 目录
## 4-screen-biological-evolution-star-3D
- [多页面联动.md](#多页面联动.md)

## 4-screen-biological-evolution-tree-3D
- [多页面联动.md](#多页面联动.md)

## 4-screen-biological-evolution-visualization-3D
- [多页面联动.md](#多页面联动.md)

## 4-screen-display
- [4页面拼合.md](#4页面拼合.md)

## 4-screen-home-page
- [页面多选.md](#页面多选.md)

## biological-classification-sunburst-2D
- [太阳爆发图.md](#太阳爆发图.md)
- [搜索.md](#搜索.md)
- [放大镜.md](#放大镜.md)
- [数据绑定.md](#数据绑定.md)
- [鼠标交互效果.md](#鼠标交互效果.md)

## biological-evolution-dna-3D
- [DNA双螺旋模型.md](#DNA双螺旋模型.md)
- [动态星空效果.md](#动态星空效果.md)
- [数据绑定.md](#数据绑定.md)
- [时间旅行 - 倍速.md](#时间旅行 - 倍速.md)
- [时间旅行 - 播放.md](#时间旅行 - 播放.md)
- [时间旅行 - 视角转换.md](#时间旅行 - 视角转换.md)
- [画面旋转 - 鼠标与键盘控制.md](#画面旋转 - 鼠标与键盘控制.md)

## biological-evolution-force-2D
- [力导向图.md](#力导向图.md)
- [数据绑定.md](#数据绑定.md)
- [树状JSON数据转化为力导向图.md](#树状JSON数据转化为力导向图.md)
- [鼠标左击节点.md](#鼠标左击节点.md)
- [鼠标悬停.md](#鼠标悬停.md)

## biological-evolution-star-3D
- [树状模型.md](#树状模型.md)
- [模型参数动态调整.md](#模型参数动态调整.md)
- [相机视角过渡.md](#相机视角过渡.md)
- [节点光圈高亮.md](#节点光圈高亮.md)

## biological-evolution-tree-2D
- [搜索节点并平滑过渡.md](#搜索节点并平滑过渡.md)
- [时间段过滤器.md](#时间段过滤器.md)
- [树状图.md](#树状图.md)
- [节点的创建与定位.md](#节点的创建与定位.md)

## biological-evolution-tree-3D
- [readme.txt](#readme.txt)

## biological-evolution-visualization-3D
- [三维力导向图 - 补充.md](#三维力导向图 - 补充.md)
- [三维力导向图.md](#三维力导向图.md)
- [天空盒.md](#天空盒.md)

## home-page
- [选项卡.md](#选项卡.md)

## index
- [设备检测.md](#设备检测.md)

## index-earth
- [地球模型与纹理贴图.md](#地球模型与纹理贴图.md)

## paleo-geography-3D
- [地球模型与纹理贴图.md](#地球模型与纹理贴图.md)

## pc-index
- [旋转立方体.md](#旋转立方体.md)

## radial-tidy-tree
- [搜索.md](#搜索.md)
- [放射状树形图.md](#放射状树形图.md)
- [旋转树形图.md](#旋转树形图.md)
- [时间线筛选.md](#时间线筛选.md)

## 其他页面-无

# 4-screen-biological-evolution-star-3D

## 多页面联动.md

### 实验报告：多页面联动的实现分析

#### 1. 引言
在现代Web应用中，多页面联动是一个常见的需求，尤其是在使用iframe嵌套的情况下。通过发送和接收消息，可以实现不同页面之间的交互。本文将分析一段HTML代码，探讨其如何实现多页面联动，包括消息的发送、接收及存放。

#### 2. 代码分析

##### 2.1 消息发送

在代码中，消息的发送主要通过`window.parent.postMessage`方法实现。以下是相关代码片段：

```javascript
// 更新相机位置
if (window.parent && window.frameElement) {
    window.parent.postMessage({
        sourceQuadrant: window.frameElement.id.replace('iframe-', ''),
        nodeId: selectedObject.userData.name,
        action: 'click'
    }, window.location.origin);
}
```

**分析：**
- 当用户点击某个节点时，代码会获取该节点的相关信息（如`nodeId`）并构建一个消息对象。
- `postMessage`方法将消息发送到父窗口，消息内容包括：
  - `sourceQuadrant`: 当前iframe的ID，去掉前缀`iframe-`。
  - `nodeId`: 被点击节点的名称。
  - `action`: 指定的动作，这里是`click`。

##### 2.2 消息接收

接收消息的部分代码如下：

```javascript
window.addEventListener('message', (event) => {
    if (event.origin === window.location.origin) {
        const { nodeId, action, sourceQuadrant } = event.data;
        
        if (sourceQuadrant === window.frameElement?.id.replace('iframe-', '')) return;

        if (action === 'click') {
            const node = networkGroup.children.find(obj => 
                obj instanceof THREE.Mesh && obj.userData.name === nodeId
            );
            if (node) {
                // 显示节点信息
                showEventDetails(node.userData);
                
                // 创建高亮效果
                createHighlightCircle(node.position, node);
                
                // 更新相机位置
                const nodePosition = node.position;
                const directionToOrigin = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), nodePosition).normalize();
                targetPosition.copy(nodePosition).add(directionToOrigin.multiplyScalar(-30));
                targetLookAt.copy(nodePosition);

                isTransitioning = true;
                isInfoDisplayed = true;
            }
        }
    }
});
```

**分析：**
- 通过`window.addEventListener('message', ...)`，代码监听来自其他窗口的消息。
- 首先，检查消息的来源是否与当前页面相同，以确保安全性。
- 如果消息的`action`是`click`，则根据`nodeId`查找对应的节点。
- 找到节点后，调用`showEventDetails`和`createHighlightCircle`函数来显示节点信息和高亮效果，并更新相机位置。

##### 2.3 消息存放

消息本身并不存放在特定的地方，而是通过事件机制在页面间传递。每当一个页面发送消息时，另一个页面通过事件监听器接收并处理这些消息。

#### 3. 流程总结

1. **用户交互**：用户点击某个节点。
2. **消息构建**：点击事件触发，构建包含节点信息的消息对象。
3. **消息发送**：通过`postMessage`将消息发送到父窗口。
4. **消息接收**：父窗口的iframe通过`message`事件监听器接收消息。
5. **消息处理**：根据消息内容，查找对应的节点并更新界面（如显示信息、创建高亮效果等）。

#### 4. 结论

通过`postMessage`和`message`事件，Web应用能够实现不同页面之间的有效通信。这种机制不仅简化了多页面联动的实现，还增强了用户体验。通过对代码的分析，我们可以看到，消息的发送和接收是通过事件驱动的方式进行的，确保了信息的及时传递和处理。


# 4-screen-biological-evolution-tree-3D

## 多页面联动.md

### 实验报告：多页面联动实现分析

#### 1. 概述
在该HTML文件中，实现了多页面联动的功能，主要通过`postMessage` API进行消息的发送与接收。该功能允许不同的页面（如iframe和父页面）之间进行通信，从而实现数据的共享和交互。

#### 2. 消息发送与接收机制

##### 2.1 消息发送
在代码中，消息的发送主要通过`window.parent.postMessage`实现。以下是相关代码片段：

```javascript
// 在节点点击处理函数中
function onNodeClick(event) {
    // ... 省略部分代码 ...
    if (selectedObject.userData && selectedObject.userData.name) {
        // 显示节点信息
        showEventDetails(selectedObject.userData);
        
        // 发送消息给父页面
        if (window.parent && window.frameElement) {
            window.parent.postMessage({
                sourceQuadrant: window.frameElement.id.replace('iframe-', ''),
                nodeId: selectedObject.userData.name,
                action: 'click'
            }, window.location.origin);
        }
    }
}
```

在`onNodeClick`函数中，当用户点击某个节点时，首先会显示该节点的信息，然后通过`postMessage`将消息发送给父页面。消息内容包括：
- `sourceQuadrant`: 当前iframe的ID，去掉前缀`iframe-`。
- `nodeId`: 被点击节点的名称。
- `action`: 指定的动作，这里是`click`。

##### 2.2 消息接收
父页面通过添加事件监听器来接收来自iframe的消息。相关代码如下：

```javascript
// 添加事件监听器以接收来自 iframe 的消息
window.addEventListener('message', (event) => {
    if (event.origin === window.location.origin) {
        const { nodeId, action, sourceQuadrant } = event.data;
        
        // 确保不处理来自自己的消息
        const currentQuadrant = window.frameElement?.id.replace('iframe-', '');
        if (sourceQuadrant === currentQuadrant) return;

        if (action === 'click') {
            const node = networkGroup.children.find(obj => 
                obj instanceof THREE.Mesh && obj.userData.name === nodeId
            );
            if (node) {
                simulateNodeClick(node);
            }
        }
    }
});
```

在父页面中，`message`事件的监听器会检查消息的来源是否与当前页面相同，以确保安全性。接收到的消息会被解析，提取出`nodeId`、`action`和`sourceQuadrant`。如果`action`是`click`，则会根据`nodeId`查找对应的节点，并调用`simulateNodeClick`函数进行处理。

#### 3. 消息存放与处理
消息的存放主要是通过`event.data`对象来实现。每当发送或接收消息时，相关数据都会被封装在这个对象中。具体的处理流程如下：

1. **发送消息**：
   - 用户点击节点，触发`onNodeClick`函数。
   - 函数中构建消息对象并通过`postMessage`发送。

2. **接收消息**：
   - 父页面的`message`事件监听器被触发。
   - 解析`event.data`，提取出需要的信息。
   - 根据`action`的类型进行相应的处理。

#### 4. 代码流程分析
- **用户交互**：用户在iframe中点击某个节点。
- **消息发送**：`onNodeClick`函数被调用，构建消息并发送给父页面。
- **消息接收**：父页面的`message`事件监听器接收到消息，解析并处理。
- **节点高亮**：根据接收到的`nodeId`，在父页面中高亮显示对应的节点。

#### 5. 总结
该HTML文件通过`postMessage` API实现了多页面之间的联动，允许iframe与父页面之间进行有效的通信。消息的发送与接收机制清晰，确保了数据的安全性和准确性。通过这种方式，可以实现复杂的交互效果，提升用户体验。

# 4-screen-biological-evolution-visualization-3D

## 多页面联动.md

### 实验报告：多页面联动实现分析

#### 1. 概述
在该HTML文件中，实现了多页面联动的功能，主要通过`postMessage` API进行消息的发送与接收。该机制允许不同的窗口或iframe之间进行安全的跨源通信。以下将详细分析代码中如何实现这一功能，包括消息的发送、接收、父页面的监听以及消息的存放。

#### 2. 消息发送
在代码中，消息的发送主要发生在用户点击节点时。具体实现如下：

```javascript
renderer.domElement.addEventListener('click', (event) => {
    event.preventDefault();

    mouse.x = (event.clientX / (window.innerWidth / 2)) * 2 - 1;
    mouse.y = -(event.clientY / (window.innerHeight / 2)) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(
        nodes.map(node => node.object).filter(obj => obj),
        false
    );

    if (intersects.length > 0) {
        const nodeData = nodes.find(n => n.object === intersects[0].object);
        if (nodeData) {
            // 处理本地点击效果
            simulateNodeClick(nodeData);
            
            // 向父页面发送消息
            if (window.parent && window.frameElement) {
                const quadrantId = window.frameElement.id.replace('iframe-', '');
                console.log(`Sending click event from quadrant ${quadrantId} for node: ${nodeData.id}`);
                
                window.parent.postMessage({
                    sourceQuadrant: quadrantId,
                    nodeId: nodeData.id,
                    action: 'click'
                }, window.location.origin);
            }
        }
    }
});
```

**分析：**
- 通过`renderer.domElement.addEventListener('click', ...)`为渲染器的DOM元素添加点击事件监听器。
- 使用`raycaster`检测用户点击的节点，并获取相关的节点数据。
- 如果点击了有效的节点，调用`simulateNodeClick(nodeData)`处理本地效果。
- 通过`window.parent.postMessage(...)`向父页面发送消息，消息内容包括：
  - `sourceQuadrant`: 当前iframe的ID，标识消息来源。
  - `nodeId`: 被点击节点的ID。
  - `action`: 动作类型，这里是`click`。

#### 3. 消息接收
在父页面中，接收消息的代码如下：

```javascript
window.addEventListener('message', (event) => {
    try {
        if (event.origin === window.location.origin) {
            const { nodeId, action, sourceQuadrant } = event.data;
            
            // 确保不处理来自自己的消息
            const currentQuadrant = window.frameElement?.id.replace('iframe-', '');
            if (sourceQuadrant === currentQuadrant) {
                return;
            }

            if (action === 'click') {
                const clickedNode = findNodeById(nodeId);
                if (clickedNode) {
                    console.log(`Processing click event for node: ${nodeId} in iframe: ${currentQuadrant}`);
                    simulateNodeClick(clickedNode);
                } else {
                    console.warn(`Node with id ${nodeId} not found in iframe: ${currentQuadrant}`);
                }
            }
        }
    } catch (error) {
        console.error('Error processing message:', error);
    }
});
```

**分析：**
- 使用`window.addEventListener('message', ...)`监听来自其他窗口或iframe的消息。
- 检查消息的来源是否与当前页面相同，以确保安全性。
- 提取消息中的`nodeId`、`action`和`sourceQuadrant`。
- 确保不处理来自自身的消息，避免循环。
- 如果`action`为`click`，则调用`findNodeById(nodeId)`查找对应的节点，并执行`simulateNodeClick(clickedNode)`来处理点击效果。

#### 4. 消息存放
消息的存放主要在`event.data`中。发送的消息通过`postMessage`方法传递，接收时通过`event.data`获取。消息的结构如下：

```javascript
{
    sourceQuadrant: quadrantId,
    nodeId: nodeData.id,
    action: 'click'
}
```

#### 5. 流程总结
1. 用户在子页面中点击节点。
2. 子页面通过`raycaster`检测到点击的节点，并获取节点数据。
3. 子页面调用`postMessage`向父页面发送包含节点信息的消息。
4. 父页面通过`message`事件监听器接收消息，验证消息来源。
5. 父页面根据消息内容执行相应的操作，如高亮节点或更新信息面板。

#### 6. 结论
通过`postMessage` API，子页面与父页面之间实现了有效的通信机制。该机制不仅保证了安全性，还允许灵活的多页面联动，增强了用户交互体验。

# 4-screen-display

## 4页面拼合.md

### 代码流程分析报告

该HTML文件实现了一个四象限展示页面，用户可以通过URL参数选择四个不同的卡片，并在页面中以四个象限的形式展示这些卡片的内容。以下是代码的详细分析：

#### 1. HTML结构

- **文档类型和语言设置**：
  ```html
  <!DOCTYPE html>
  <html lang="zh">
  ```
  该文档声明为HTML5，并设置语言为中文。

- **头部信息**：
  ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="icon" href="./static-other/icon/favicon.ico" type="image/x-icon">
      <title>四象限展示</title>
      <style>
          /* CSS样式定义 */
      </style>
  </head>
  ```
  头部包含字符集、视口设置、图标链接和标题。CSS样式定义了页面的布局和样式。

#### 2. CSS样式

- **页面布局**：
  ```css
  body {
      display: flex;
      flex-wrap: wrap;
      height: 100vh;
      margin: 0;
      box-sizing: border-box;
  }
  ```
  使用Flexbox布局，使页面能够自适应高度并且内容能够换行。

- **象限样式**：
  ```css
  .quadrant {
      width: calc(50% - 2px);
      height: calc(50% - 2px);
      position: relative;
      overflow: hidden;
      border: 1px solid #ccc;
      margin: 1px;
  }
  ```
  每个象限的宽高设置为页面的一半，减去边框宽度，确保四个象限能够在页面中均匀分布。

#### 3. JavaScript逻辑

- **获取URL参数**：
  ```javascript
  const urlParams = new URLSearchParams(window.location.search);
  const cards = urlParams.get('cards').split(',');
  ```
  使用`URLSearchParams`获取URL中的`cards`参数，并将其分割成数组。

- **检查卡片数量**：
  ```javascript
  if (cards.length === 4) {
      loadContent('top-left', cards[0]);
      loadContent('top-right', cards[1]);
      loadContent('bottom-left', cards[2]);
      loadContent('bottom-right', cards[3]);
  } else {
      document.body.innerHTML = '<h1>错误: 请选择四个选项卡。</h1>';
  }
  ```
  检查是否有四个卡片被选中。如果是，则调用`loadContent`函数加载每个象限的内容；否则，显示错误信息。

- **加载子页面内容**：
  ```javascript
  function loadContent(quadrantId, cardName) {
      const iframe = document.createElement('iframe');
      iframe.src = `./4-screen-${cardName}.html`;
      document.getElementById(quadrantId).appendChild(iframe);
  }
  ```
  创建一个`iframe`元素，并设置其源为对应卡片的HTML文件。然后将其添加到指定的象限中。

- **接收来自iframe的消息**：
  ```javascript
  window.addEventListener('message', (event) => {
      if (event.origin === window.location.origin) {
          const { quadrantId, data } = event.data;
          updateQuadrant(quadrantId, data);
      }
  });
  ```
  监听来自`iframe`的消息，确保消息来源是同一源，并调用`updateQuadrant`函数更新对应象限的内容。

- **更新象限内容**：
  ```javascript
  function updateQuadrant(quadrantId, data) {
      const quadrant = document.getElementById(quadrantId);
      quadrant.innerHTML = `<h2>选中数据: ${data}</h2>`;
  }
  ```
  根据接收到的数据更新指定象限的内容。

#### 4. 返回导航页按钮

- **按钮实现**：
  ```html
  <button onclick="goBack()">返 回 导 航 页</button>
  ```
  创建一个按钮，点击后调用`goBack`函数返回导航页。

- **返回导航页的函数**：
  ```javascript
  function goBack() {
      window.location.href = './pc-index.html';
  }
  ```
  将窗口的URL更改为导航页的路径。

### 总结

该代码通过使用HTML、CSS和JavaScript实现了一个动态的四象限展示页面。用户可以通过URL参数选择四个卡片，页面会自动加载并展示这些卡片的内容。通过`iframe`的使用，页面能够在不重新加载的情况下展示不同的内容，同时提供了返回导航页的功能。

# 4-screen-home-page

## 页面多选.md

### 多选功能代码流程分析报告

该页面的多选功能主要通过 JavaScript 实现，具体流程如下：

1. **图片数组定义**：
   ```javascript
   const images = [
       'biological-classification-sunburst-2D',
       'biological-evolution-force-2D',
       'biological-evolution-tree-2D',
       'biological-evolution-dna-3D',
       'biological-evolution-star-3D',
       'biological-evolution-tree-3D',
       'biological-evolution-visualization-3D',
       'paleo-geography-3D'
   ];
   ```
   - 定义了一个包含多个图片名称的数组 `images`，这些名称将用于生成卡片。

2. **选中卡片数组**：
   ```javascript
   let selectedCards = [];
   ```
   - 初始化一个空数组 `selectedCards`，用于存储用户选中的卡片。

3. **生成卡片**：
   ```javascript
   images.forEach(img => {
       document.write(`
           <div class="card-wrapper" data-img="${img}">
               <a href="javascript:void(0);" class="select-card">
                   <div class="card">
                       <div class="card-face card-front">
                           <img src="./select-cards/${img}.png" alt="${img}">
                       </div>
                       <div class="card-face card-back">
                           <span>点击查看详情</span>
                       </div>
                       <div class="checkmark" style="display: none;">✔</div>
                   </div>
               </a>
           </div>
       `);
   });
   ```
   - 使用 `forEach` 遍历 `images` 数组，为每个图片生成一个卡片的 HTML 结构。
   - 每个卡片包含前面和后面的面，前面显示图片，后面显示“点击查看详情”的文本。
   - 还包含一个用于显示选中状态的勾选标记（`checkmark`），初始状态为隐藏。

4. **添加点击事件**：
   ```javascript
   document.querySelectorAll('.select-card').forEach(card => {
       card.addEventListener('click', () => {
           const cardWrapper = card.parentElement;
           const img = cardWrapper.getAttribute('data-img');
           const cardElement = cardWrapper.querySelector('.card');
   
           if (selectedCards.includes(img)) {
               selectedCards = selectedCards.filter(selected => selected !== img);
               cardWrapper.querySelector('.checkmark').style.display = 'none';
               cardElement.classList.remove('selected'); // 移除选中样式
           } else {
               if (selectedCards.length < 4) {
                   selectedCards.push(img);
                   cardWrapper.querySelector('.checkmark').style.display = 'block';
                   cardElement.classList.add('selected'); // 添加选中样式
               }
           }
   
           if (selectedCards.length === 4) {
               // 跳转到新的页面
               const newPageUrl = `4-screen-display.html?cards=${selectedCards.join(',')}`;
               window.location.href = newPageUrl;
           }
       });
   });
   ```
   - 为每个卡片添加点击事件监听器。
   - 当用户点击卡片时，首先获取该卡片的 `data-img` 属性值（即图片名称）。
   - 检查该图片是否已经在 `selectedCards` 数组中：
     - 如果已选中，则从 `selectedCards` 中移除该图片，并隐藏勾选标记，移除选中样式。
     - 如果未选中且当前选中的卡片数量少于 4，则将该图片添加到 `selectedCards` 中，显示勾选标记，并添加选中样式。
   - 当选中的卡片数量达到 4 时，构建新的页面 URL，并跳转到该页面，传递选中的卡片信息。

5. **总结**：
   - 该页面通过 JavaScript 动态生成卡片，并使用事件监听器管理用户的选择。用户可以选择最多 4 张卡片，选中状态通过 CSS 类和勾选标记进行视觉反馈。最终，用户的选择会被传递到新的页面进行处理。

# biological-classification-sunburst-2D

## 太阳爆发图.md

### 太阳爆发图效果实现分析

太阳爆发图（Sunburst Chart）是一种用于可视化层次结构数据的图表，通常用于展示分类数据的关系。以下是实现该效果的具体代码流程分析。

#### 1. 数据结构与准备

在代码中，太阳爆发图的数据结构通常是一个树形结构，包含节点及其子节点的信息。数据通过 `biological-classification-data.js` 文件加载，具体数据结构未在提供的代码中展示，但可以推测为包含 `name`, `children`, `src`, `time`, `description` 等属性的对象。

#### 2. 定义常量与初始化

在脚本的开头，定义了一些常量和变量，用于设置图表的宽度、高度、半径等参数。

```javascript
const width = 1000;
const height = 1000;
const radius = Math.min(width, height) / 2.0;
let currentRotation = 0;
let dragStartRotation = 0;
let dragStartAngle = 0;
let isDragging = false;
let rotationSpeed = 2; // 每次旋转的角度
```

- **宽度和高度**：设置图表的宽度和高度为 1000 像素。
- **半径**：计算图表的半径为宽度和高度的最小值的一半。
- **旋转变量**：定义了一些变量用于处理图表的旋转和拖拽。

#### 3. 创建颜色生成函数

颜色生成函数 `color(d)` 用于根据节点的深度和所属分支生成不同的颜色。

```javascript
const color = d => {
    let node = d;
    while (node.parent) {
        if (node.data.name === "动物界") {
            return d3.scaleLinear()
                .domain([0, 5])
                .range(["#FFA500", "#FF8C00"])(d.depth); // 橙色系
        }
        // 其他分支的颜色定义...
        node = node.parent;
    }
    return d3.scaleLinear()
        .domain([0, 5])
        .range(["#FF8C00", "#FF4500"])(d.depth); // 默认颜色
};
```

- **颜色映射**：根据节点的深度和所属分支，使用 D3.js 的线性比例尺生成不同的颜色。

#### 4. 创建 SVG 元素

使用 D3.js 创建 SVG 元素，并设置其宽度和高度。

```javascript
const svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", `translate(${width/2},${height/2})`);
```

- **SVG 画布**：创建一个 SVG 画布，并将其中心点移动到画布的中心，以便于后续的旋转和缩放操作。

#### 5. 创建分区布局

使用 D3.js 的分区布局函数 `partition` 来处理数据。

```javascript
const partition = data => {
    const root = d3.hierarchy(data)
        .sum(d => 1)
        .sort((a, b) => b.value - a.value);
    return d3.partition()
        .size([2 * Math.PI, radius])
        .padding(0.005)(root);
};
```

- **层次结构**：使用 `d3.hierarchy` 创建层次结构，并计算每个节点的值。
- **分区布局**：使用 `d3.partition` 创建分区布局，设置角度和半径。

#### 6. 创建弧生成器

使用 D3.js 的弧生成器 `arc` 来生成每个节点的弧形路径。

```javascript
const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .padAngle(0.005)
    .padRadius(radius / 2)
    .innerRadius(d => d.y0)
    .outerRadius(d => d.y1 - 1);
```

- **弧形路径**：根据节点的起始角度和结束角度生成弧形路径，设置内半径和外半径。

#### 7. 处理数据并创建路径

处理数据并为每个节点创建路径。

```javascript
const root = partition(data);
root.each(d => d.current = d);

const path = svg.append("g")
    .selectAll("path")
    .data(root.descendants().slice(1))
    .join("path")
    .attr("fill", d => color(d))
    .attr("fill-opacity", 0.8)
    .attr("d", d => arc(d.current))
    .attr("class", "node")
    .attr("data-name", d => d.data.name)
    .attr("stroke", "#fff")
    .attr("stroke-width", "1px");
```

- **路径生成**：为每个节点生成路径，并设置填充颜色、透明度和边框样式。

#### 8. 创建文本标签

为每个节点创建文本标签，显示节点名称。

```javascript
const text = svg.append("g")
    .attr("pointer-events", "none")
    .selectAll("text")
    .data(root.descendants().slice(1))
    .join("text")
    .attr("class", d => `depth-${d.depth}`)
    .attr("transform", function(d) {
        const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
        const y = (d.y0 + d.y1) / 2;
        return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
    })
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .text(d => d.data.name);
```

- **文本标签**：根据节点的深度和位置生成文本标签，并设置旋转和对齐方式。

#### 9. 添加拖拽功能

实现图表的拖拽功能，使用户可以通过鼠标拖动来旋转图表。

```javascript
d3.select("body")
    .style("cursor", "move")
    .on("mousedown", dragstarted)
    .on("mousemove", dragged);

d3.select(window)
    .on("mouseup", dragended)
    .on("mouseleave", dragended);

function dragstarted(event) {
    isDragging = true;
    dragStartAngle = Math.atan2(event.pageY - height/2, event.pageX - width/2) * 180 / Math.PI;
    dragStartRotation = currentRotation;
}

function dragged(event) {
    if (!isDragging) return;
    const currentAngle = Math.atan2(event.pageY - height/2, event.pageX - width/2) * 180 / Math.PI;
    const deltaAngle = currentAngle - dragStartAngle;
    currentRotation = dragStartRotation + deltaAngle;
    svg.attr("transform", `translate(${width/2},${height/2}) rotate(${currentRotation})`);
}

function dragended() {
    isDragging = false;
}
```

- **拖拽事件**：通过 `mousedown`, `mousemove`, 和 `mouseup` 事件实现拖拽功能，更新当前旋转角度。

#### 10. 鼠标悬停效果

为每个节点添加鼠标悬停效果，显示相关信息。

```javascript
path.on("mouseover", function(event, d) {
    const infoPanel = d3.select(".info-panel");
    
    d3.select("#species-image")
        .attr("src", d.data.src || "")
        .style("display", d.data.src ? "block" : "none");
    
    d3.select("#species-description")
        .style("text-align", "center")
        .html(`
            <strong style="font-size: 1.5em; margin-bottom: 15px; display: block;">${d.data.name}</strong>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>时期:</strong> ${d.data.time}
            </div>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>简要描述:</strong> ${d.data.description}
            </div>
            ${d.data.description_more ? `
                <div style="margin: 12px 0; font-size: 1.1em;">
                    <strong>详细描述:</strong> ${d.data.description_more}
                </div>
            ` : ''}
        `);

    infoPanel
        .style("opacity", "1")
        .style("visibility", "visible");
})
.on("mouseout", function() {
    if (!isFixed) {
        d3.select("#species-image").style("display", "none");
        d3.select("#species-description")
            .html('<h1 style="font-size: 3em; text-align: center; margin-top: 50px;"> 生 物 分 类 </h1>');
    }
});
```

- **信息面板**：在鼠标悬停时更新右侧信息面板，显示节点的详细信息。

### 总结

太阳爆发图的实现通过 D3.js 库的强大功能，结合层次结构数据的处理、SVG 元素的创建、颜色映射、拖拽功能和鼠标悬停效果，形成了一个交互性强、视觉效果好的图表。整体实现逻辑清晰，用户体验良好，能够有效展示生物分类的层次结构。

## 搜索.md

### 搜索功能实现分析

#### 1. 数据结构与初始化

搜索功能的核心在于对生物分类数据的遍历和搜索。代码中定义了一个函数 `getAllNodes(data)`，用于遍历数据并生成一个包含所有节点的数组。每个节点包含名称、路径和数据。

```javascript
function getAllNodes(data) {
    let nodes = [];
    
    function traverse(node, path = []) {
        const currentPath = [...path, node.name];
        nodes.push({
            name: node.name,
            path: currentPath,
            data: node
        });
        
        if (node.children) {
            node.children.forEach(child => traverse(child, currentPath));
        }
    }
    
    traverse(data);
    return nodes;
}
```

- **遍历过程**：使用递归遍历每个节点，构建一个包含所有节点信息的数组 `nodes`。

#### 2. 搜索输入框与事件监听

搜索框的输入框通过 `searchInput` 变量获取，并添加了 `input` 事件监听器，以便在用户输入时触发搜索。

```javascript
const searchInput = document.getElementById('searchInput');
searchInput.addEventListener('input', function(e) {
    const searchTerm = e.target.value.toLowerCase();
    // 清除之前的高亮
    if (activeHighlight) {
        path.attr("fill", d => color(d))
            .attr("fill-opacity", 0.8);
        activeHighlight = null;
    }
    
    if (searchTerm.length < 1) {
        showSearchHistory(); // 显示搜索历史
        return;
    }
    
    // 搜索节点
    const matches = root.descendants()
        .filter(node => node.data.name.toLowerCase().includes(searchTerm))
        .map(node => ({
            name: node.data.name,
            path: getNodePath(node),
            data: node
        }));
    
    searchResults.innerHTML = '';
    searchResults.style.display = matches.length ? 'block' : 'none';
    
    matches.forEach(match => {
        const div = document.createElement('div');
        div.className = 'search-result-item';
        div.textContent = match.path.join(' > ');
        
        div.addEventListener('click', () => {
            handleSearchResultClick(match);
        });
        
        searchResults.appendChild(div);
    });
});
```

- **输入事件处理**：当用户在搜索框中输入内容时，首先将输入内容转换为小写字母，然后根据输入内容过滤出匹配的节点。
- **显示搜索结果**：将匹配的结果显示在 `searchResults` 容器中。

#### 3. 搜索结果的处理

当用户点击搜索结果时，调用 `handleSearchResultClick(match)` 函数来处理点击事件。

```javascript
function handleSearchResultClick(match) {
    const targetNode = root.descendants().find(d => d.data.name === match.name);
    if (!targetNode) return;

    // 高亮显示找到的节点
    path.attr("fill", d => {
        if (d.data.name === match.name) {
            activeHighlight = d;
            return "#FFD700"; // 高亮颜色
        }
        return color(d);
    }).attr("fill-opacity", d => d.data.name === match.name ? 1 : 0.8);
    
    // 更新信息面板
    updateInfoPanel(targetNode);
    
    // 添加到搜索历史
    addToSearchHistory({
        name: match.name,
        path: getNodePath(targetNode),
        data: targetNode
    });
    
    // 清空搜索框和结果
    searchInput.value = '';
    searchResults.style.display = 'none';
    
    // 自动旋转到目标节点
    const targetAngle = ((targetNode.x0 + targetNode.x1) / 2 * 180 / Math.PI) - 90;
    currentRotation = -targetAngle;
    updateRotation();
}
```

- **高亮显示**：根据匹配的节点名称高亮显示对应的节点。
- **更新信息面板**：调用 `updateInfoPanel(targetNode)` 更新右侧信息面板的内容。
- **搜索历史**：将搜索结果添加到搜索历史中，以便用户可以快速访问。
- **清空搜索框**：在处理完搜索结果后，清空搜索框的内容并隐藏搜索结果。

#### 4. 搜索历史的管理

搜索历史的管理通过 `addToSearchHistory(item)` 和 `showSearchHistory()` 函数实现。

```javascript
function addToSearchHistory(item) {
    const existingIndex = searchHistory.findIndex(historyItem => historyItem.name === item.name);
    
    if (existingIndex !== -1) {
        searchHistory.splice(existingIndex, 1);
    }
    
    searchHistory.unshift({
        name: item.name,
        path: item.path,
        data: item.data
    });
    
    if (searchHistory.length > MAX_HISTORY_ITEMS) {
        searchHistory.pop();
    }

    localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
}

function showSearchHistory() {
    searchResults.innerHTML = '';
    
    if (searchHistory.length > 0) {
        searchResults.style.display = 'block';
        
        const historyTitle = document.createElement('div');
        historyTitle.className = 'search-history-title';
        
        const titleText = document.createElement('span');
        titleText.textContent = '搜索历史';
        
        const clearButton = document.createElement('button');
        clearButton.className = 'clear-history';
        clearButton.textContent = '清空历史';
        clearButton.onclick = clearSearchHistory;
        
        historyTitle.appendChild(titleText);
        historyTitle.appendChild(clearButton);
        searchResults.appendChild(historyTitle);
        
        searchHistory.forEach(item => {
            const div = document.createElement('div');
            div.className = 'search-result-item';
            div.textContent = item.path.join(' > ');
            
            div.addEventListener('click', () => {
                handleSearchResultClick(item);
            });
            
            searchResults.appendChild(div);
        });
    }
}
```

- **添加历史记录**：在添加新搜索项时，检查是否已存在相同项，如果存在则移到开头，并限制历史记录的数量。
- **显示历史记录**：在搜索框为空时显示历史记录，用户可以点击历史记录项快速访问。

### 总结

搜索功能通过遍历生物分类数据生成节点数组，利用输入框的事件监听实现动态搜索，并通过高亮显示和信息面板更新提供用户反馈。同时，搜索历史的管理使得用户可以方便地访问之前的搜索结果。整体实现逻辑清晰，用户体验良好。


## 放大镜.md

放大镜效果的实现主要依赖于以下几个部分的代码。下面我将详细分析这些部分的工作流程。

### 1. HTML 结构
在 HTML 中，有一个用于放大镜的 `div` 和一个 `canvas` 元素：
```html
<div id="magnifier">
    <canvas id="magnifierCanvas"></canvas>
</div>
```
这个 `div` 是放大镜的容器，`canvas` 用于绘制放大效果。

### 2. CSS 样式
放大镜的样式设置在 CSS 中，确保它在页面上固定位置并且有合适的大小：
```css
#magnifier {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 250px;
    height: 250px;
    border: 3px solid rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    overflow: hidden;
    z-index: 1000;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    pointer-events: none; /* 防止放大镜阻挡鼠标事件 */
}
```

### 3. JavaScript 逻辑
放大镜的主要逻辑在 JavaScript 中实现，以下是关键部分的分析：

#### 3.1 初始化
在 JavaScript 中，首先获取放大镜和画布的元素：
```javascript
const magnifier = document.getElementById('magnifier');
const canvas = document.getElementById('magnifierCanvas');
const ctx = canvas.getContext('2d');
```
这里 `ctx` 是用于在 `canvas` 上绘制的上下文。

#### 3.2 创建离屏 Canvas
为了提高性能，使用一个离屏 `canvas` 进行双缓冲：
```javascript
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d');
```
这个离屏 `canvas` 用于在放大镜中绘制放大的 SVG 图像。

#### 3.3 设置 Canvas 尺寸
设置放大镜和离屏 `canvas` 的实际尺寸：
```javascript
canvas.width = canvas.height = 250;
offscreenCanvas.width = offscreenCanvas.height = 250;
```

#### 3.4 放大倍数
定义放大倍数：
```javascript
const ZOOM = 2.5;
```

#### 3.5 防抖函数
为了优化性能，使用防抖函数来限制放大镜更新的频率：
```javascript
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
```

#### 3.6 更新放大镜内容
更新放大镜内容的函数：
```javascript
function updateMagnifier(e) {
    const svgElement = document.querySelector('svg');
    if (!svgElement) return;

    // 获取SVG的位置和尺寸
    const svgRect = svgElement.getBoundingClientRect();
    const mouseX = e.clientX - svgRect.left;
    const mouseY = e.clientY - svgRect.top;

    // 清除离屏canvas
    offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
    
    // 创建圆形裁剪区域
    offscreenCtx.save();
    offscreenCtx.beginPath();
    offscreenCtx.arc(offscreenCanvas.width / 2, offscreenCanvas.height / 2, offscreenCanvas.width / 2, 0, Math.PI * 2);
    offscreenCtx.clip();

    // 将SVG转换为图片
    const svgString = new XMLSerializer().serializeToString(svgElement);
    const img = new Image();
    const blob = new Blob([svgString], {type: 'image/svg+xml'});
    const url = URL.createObjectURL(blob);

    img.onload = () => {
        // 计算缩放和位置
        const scale = ZOOM;
        const dx = offscreenCanvas.width / 2 - mouseX * scale;
        const dy = offscreenCanvas.height / 2 - mouseY * scale;

        // 在离屏canvas上绘制
        offscreenCtx.drawImage(img, dx, dy, svgRect.width * scale, svgRect.height * scale);
        offscreenCtx.restore();

        // 将离屏canvas的内容复制到显示canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(offscreenCanvas, 0, 0);

        URL.revokeObjectURL(url);
    };

    img.src = url;
}
```
- **获取 SVG 的位置和尺寸**：通过 `getBoundingClientRect()` 获取 SVG 的位置和尺寸，以便计算鼠标相对于 SVG 的位置。
- **清除离屏 Canvas**：在每次更新前清除离屏 `canvas` 的内容。
- **创建圆形裁剪区域**：使用 `arc` 方法创建一个圆形的裁剪区域。
- **将 SVG 转换为图片**：使用 `XMLSerializer` 将 SVG 转换为字符串，然后创建一个 Blob 对象并生成 URL。
- **绘制放大图像**：在离屏 `canvas` 上绘制放大的 SVG 图像。
- **更新显示 Canvas**：将离屏 `canvas` 的内容绘制到显示的 `canvas` 上。

#### 3.7 鼠标移动事件
最后，使用防抖处理更新放大镜内容的鼠标移动事件：
```javascript
document.addEventListener('mousemove', (e) => {
    if (magnifierVisible) {
        requestAnimationFrame(() => debouncedUpdate(e));
    }
});
```
当鼠标移动时，如果放大镜可见，就调用 `debouncedUpdate` 函数更新放大镜内容。

### 总结
放大镜效果的实现通过创建离屏 `canvas`、使用防抖函数、以及在鼠标移动时更新放大内容来实现。通过这些步骤，用户在鼠标悬停时可以看到放大的图像，增强了用户体验。


## 数据绑定.md

### 数据绑定到太阳爆发图的功能实现分析

太阳爆发图的核心在于如何将数据有效地绑定到图形元素上，以便于可视化层次结构数据。以下是实现这一功能的具体代码流程分析。

#### 1. 数据结构

太阳爆发图的数据通常是一个树形结构，包含节点及其子节点的信息。每个节点可能包含以下属性：
- `name`: 节点名称
- `children`: 子节点数组
- `src`: 图片源（可选）
- `time`: 相关时间（可选）
- `description`: 简要描述（可选）
- `description_more`: 详细描述（可选）

数据通过 `biological-classification-data.js` 文件加载，具体数据结构未在提供的代码中展示，但可以推测为包含上述属性的对象。

#### 2. 创建 SVG 元素

在代码的开头，使用 D3.js 创建 SVG 元素，并设置其宽度和高度。

```javascript
const svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", `translate(${width/2},${height/2})`);
```

- **SVG 画布**：创建一个 SVG 画布，并将其中心点移动到画布的中心，以便于后续的旋转和缩放操作。

#### 3. 创建分区布局

使用 D3.js 的分区布局函数 `partition` 来处理数据。

```javascript
const partition = data => {
    const root = d3.hierarchy(data)
        .sum(d => 1)
        .sort((a, b) => b.value - a.value);
    return d3.partition()
        .size([2 * Math.PI, radius])
        .padding(0.005)(root);
};
```

- **层次结构**：使用 `d3.hierarchy` 创建层次结构，并计算每个节点的值。
- **分区布局**：使用 `d3.partition` 创建分区布局，设置角度和半径。

#### 4. 处理数据并创建路径

处理数据并为每个节点创建路径。

```javascript
const root = partition(data);
root.each(d => d.current = d);

const path = svg.append("g")
    .selectAll("path")
    .data(root.descendants().slice(1))
    .join("path")
    .attr("fill", d => color(d))
    .attr("fill-opacity", 0.8)
    .attr("d", d => arc(d.current))
    .attr("class", "node")
    .attr("data-name", d => d.data.name)
    .attr("stroke", "#fff")
    .attr("stroke-width", "1px");
```

- **数据绑定**：使用 `data(root.descendants().slice(1))` 将处理后的数据绑定到路径元素上。`root.descendants()` 返回树的所有节点，`slice(1)` 用于排除根节点。
- **路径生成**：为每个节点生成路径，并设置填充颜色、透明度和边框样式。

#### 5. 创建文本标签

为每个节点创建文本标签，显示节点名称。

```javascript
const text = svg.append("g")
    .attr("pointer-events", "none")
    .selectAll("text")
    .data(root.descendants().slice(1))
    .join("text")
    .attr("class", d => `depth-${d.depth}`)
    .attr("transform", function(d) {
        const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
        const y = (d.y0 + d.y1) / 2;
        return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
    })
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .text(d => d.data.name);
```

- **文本绑定**：同样使用 `data(root.descendants().slice(1))` 将节点数据绑定到文本元素上。
- **文本生成**：根据节点的深度和位置生成文本标签，并设置旋转和对齐方式。

#### 6. 鼠标悬停效果

为每个节点添加鼠标悬停效果，显示相关信息。

```javascript
path.on("mouseover", function(event, d) {
    const infoPanel = d3.select(".info-panel");
    
    d3.select("#species-image")
        .attr("src", d.data.src || "")
        .style("display", d.data.src ? "block" : "none");
    
    d3.select("#species-description")
        .style("text-align", "center")
        .html(`
            <strong style="font-size: 1.5em; margin-bottom: 15px; display: block;">${d.data.name}</strong>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>时期:</strong> ${d.data.time}
            </div>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>简要描述:</strong> ${d.data.description}
            </div>
            ${d.data.description_more ? `
                <div style="margin: 12px 0; font-size: 1.1em;">
                    <strong>详细描述:</strong> ${d.data.description_more}
                </div>
            ` : ''}
        `);

    infoPanel
        .style("opacity", "1")
        .style("visibility", "visible");
})
.on("mouseout", function() {
    if (!isFixed) {
        d3.select("#species-image").style("display", "none");
        d3.select("#species-description")
            .html('<h1 style="font-size: 3em; text-align: center; margin-top: 50px;"> 生 物 分 类 </h1>');
    }
});
```

- **信息面板更新**：在鼠标悬停时，更新右侧信息面板，显示节点的详细信息。通过 `d.data` 访问当前节点的数据。

### 总结

数据绑定到太阳爆发图的功能通过 D3.js 的数据绑定机制实现。首先，使用层次结构函数处理数据，然后将处理后的数据绑定到 SVG 路径和文本元素上。通过事件监听器实现鼠标悬停效果，动态更新信息面板，提供用户交互体验。整体实现逻辑清晰，能够有效展示生物分类的层次结构。

## 鼠标交互效果.md

### 鼠标悬停与左键拖动旋转太阳爆发图功能实现分析

太阳爆发图的交互功能包括鼠标悬停显示信息和左键拖动旋转图形。以下是这两个功能的具体实现流程分析。

#### 1. 鼠标悬停功能实现

鼠标悬停功能的实现主要依赖于 D3.js 的事件处理机制。具体步骤如下：

##### 1.1 事件绑定

在路径元素上绑定 `mouseover` 和 `mouseout` 事件，以便在鼠标悬停时显示相关信息。

```javascript
path.on("mouseover", function(event, d) {
    const infoPanel = d3.select(".info-panel");
    
    d3.select("#species-image")
        .attr("src", d.data.src || "")
        .style("display", d.data.src ? "block" : "none");
    
    d3.select("#species-description")
        .style("text-align", "center")
        .html(`
            <strong style="font-size: 1.5em; margin-bottom: 15px; display: block;">${d.data.name}</strong>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>时期:</strong> ${d.data.time}
            </div>
            <div style="margin: 12px 0; font-size: 1.1em;">
                <strong>简要描述:</strong> ${d.data.description}
            </div>
            ${d.data.description_more ? `
                <div style="margin: 12px 0; font-size: 1.1em;">
                    <strong>详细描述:</strong> ${d.data.description_more}
                </div>
            ` : ''}
        `);

    infoPanel
        .style("opacity", "1")
        .style("visibility", "visible");
})
.on("mouseout", function() {
    if (!isFixed) {
        d3.select("#species-image").style("display", "none");
        d3.select("#species-description")
            .html('<h1 style="font-size: 3em; text-align: center; margin-top: 50px;"> 生 物 分 类 </h1>');
    }
});
```

##### 1.2 显示信息

- **`mouseover` 事件**：当鼠标悬停在路径元素上时，获取当前节点的数据 `d`，并更新信息面板的内容，包括图片、名称、时期、简要描述和详细描述。
- **`mouseout` 事件**：当鼠标移出路径元素时，隐藏信息面板中的图片，并恢复默认的标题。

#### 2. 左键拖动旋转功能实现

左键拖动旋转功能的实现依赖于 D3.js 的事件处理和变换属性。具体步骤如下：

##### 2.1 事件绑定

在 `body` 元素上绑定 `mousedown`、`mousemove` 和 `mouseup` 事件，以便实现拖动功能。

```javascript
d3.select("body")
    .style("cursor", "move")
    .on("mousedown", dragstarted)
    .on("mousemove", dragged);

d3.select(window)
    .on("mouseup", dragended)
    .on("mouseleave", dragended);
```

##### 2.2 拖动开始

在 `dragstarted` 函数中，记录拖动的初始角度和当前旋转角度。

```javascript
function dragstarted(event) {
    isDragging = true;
    dragStartAngle = Math.atan2(event.pageY - height/2, event.pageX - width/2) * 180 / Math.PI;
    dragStartRotation = currentRotation;
}
```

- **`isDragging`**：标记当前是否正在拖动。
- **`dragStartAngle`**：计算鼠标相对于中心点的初始角度。
- **`dragStartRotation`**：记录当前的旋转角度。

##### 2.3 拖动过程

在 `dragged` 函数中，根据鼠标当前位置计算新的旋转角度，并更新 SVG 的变换属性。

```javascript
function dragged(event) {
    if (!isDragging) return;
    const currentAngle = Math.atan2(event.pageY - height/2, event.pageX - width/2) * 180 / Math.PI;
    const deltaAngle = currentAngle - dragStartAngle;
    currentRotation = dragStartRotation + deltaAngle;
    svg.attr("transform", `translate(${width/2},${height/2}) rotate(${currentRotation})`);
}
```

- **计算当前角度**：使用 `Math.atan2` 计算当前鼠标位置的角度。
- **计算角度变化**：通过当前角度与初始角度的差值计算出旋转的增量。
- **更新旋转角度**：将新的旋转角度应用到 SVG 元素的变换属性中，使图形旋转。

##### 2.4 拖动结束

在 `dragended` 函数中，重置拖动状态。

```javascript
function dragended() {
    isDragging = false;
}
```

- **重置状态**：将 `isDragging` 设置为 `false`，表示拖动结束。

### 总结

鼠标悬停功能通过事件绑定和信息面板更新实现，提供了节点的详细信息。左键拖动旋转功能则通过计算鼠标位置的角度变化，动态更新 SVG 的变换属性，使用户能够交互式地旋转太阳爆发图。这两个功能结合，使得太阳爆发图不仅具有良好的视觉效果，还提供了良好的用户体验。

# biological-evolution-dna-3D

## DNA双螺旋模型.md

### DNA双螺旋模型实现分析报告

在该HTML文件中，DNA双螺旋模型的实现主要依赖于Three.js库。以下是具体的代码流程分析：

#### 1. 创建DNA螺旋的基本结构

在`createDNASpiral`函数中，首先定义了两个曲线的点数组，用于表示DNA的两条螺旋链：

```javascript
const curve1Points = [];
const curve2Points = [];
const radius = 20;
const height = 500;
const turns = 25;
```

- **curve1Points**和**curve2Points**：分别用于存储两条螺旋链的点。
- **radius**：定义螺旋的半径。
- **height**：定义螺旋的高度。
- **turns**：定义螺旋的圈数。

#### 2. 生成螺旋链的点

通过循环生成螺旋链的点：

```javascript
for(let i = 0; i <= 360 * turns; i++) {
    const angle = (i * Math.PI) / 180;
    const y = (i / (360 * turns)) * height - height / 2;

    curve1Points.push(
        new THREE.Vector3(
            radius * Math.cos(angle),
            y,
            radius * Math.sin(angle)
        )
    );

    curve2Points.push(
        new THREE.Vector3(
            radius * Math.cos(angle + Math.PI),
            y,
            radius * Math.sin(angle + Math.PI)
        )
    );
}
```

- **angle**：计算当前点的角度。
- **y**：根据当前点的索引计算其在Y轴上的位置，形成螺旋上升的效果。
- **curve1Points**和**curve2Points**：分别存储两条螺旋链的坐标，利用三角函数计算出每个点的X和Z坐标。

#### 3. 绘制连接线

在每30个点之间绘制连接线，以增强视觉效果：

```javascript
if (i % 30 === 0) {
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(
            radius * Math.cos(angle),
            y,
            radius * Math.sin(angle)
        ),
        new THREE.Vector3(
            radius * Math.cos(angle + Math.PI),
            y,
            radius * Math.sin(angle + Math.PI)
        )
    ]);
    const lineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00ff00,
        opacity: 0.5,
        transparent: true 
    });
    const line = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(line);
}
```

- **lineGeometry**：创建连接线的几何体。
- **lineMaterial**：定义连接线的材质属性。
- **scene.add(line)**：将连接线添加到场景中。

#### 4. 创建螺旋的几何体

使用`BufferGeometry`创建两条螺旋链的几何体：

```javascript
const curve1Geometry = new THREE.BufferGeometry().setFromPoints(curve1Points);
const curve2Geometry = new THREE.BufferGeometry().setFromPoints(curve2Points);
```

- **setFromPoints**：将存储的点数组转换为几何体。

#### 5. 定义材质

为螺旋链定义材质：

```javascript
const material = new THREE.LineBasicMaterial({ 
    color: 0x00ff88,
    opacity: 0.8,
    transparent: true,
    linewidth: 2
});
```

- **LineBasicMaterial**：用于定义线条的颜色、透明度和宽度。

#### 6. 创建DNA链

使用定义好的几何体和材质创建DNA链的可视化对象：

```javascript
const dnaStrand1 = new THREE.Line(curve1Geometry, material);
const dnaStrand2 = new THREE.Line(curve2Geometry, material);

scene.add(dnaStrand1);
scene.add(dnaStrand2);
```

- **THREE.Line**：将几何体和材质结合，创建可视化的DNA链。
- **scene.add**：将DNA链添加到场景中。

### 总结

DNA双螺旋模型的实现主要依赖于Three.js的几何体和线条渲染功能。通过生成两条螺旋链的点，并在每30个点之间绘制连接线，形成了一个生动的DNA双螺旋结构。该模型不仅在视觉上真实地模拟了DNA的形态，还通过透明度和颜色的设置增强了其美观性。

## 动态星空效果.md

### 动态星空效果实现分析报告

在该HTML文件中，动态星空效果的实现主要依赖于Three.js库。以下是具体的代码流程分析：

#### 1. 创建星空的基本结构

在`createStarField`函数中，首先定义了星星的几何体和材质：

```javascript
const starsGeometry = new THREE.BufferGeometry();
const starsMaterial = new THREE.PointsMaterial({
    color: 0xFFFFFF,
    size: 0.3,
    transparent: true,
    opacity: 1.0,
    sizeAttenuation: true
});
```

- **BufferGeometry**：用于存储星星的顶点数据，适合处理大量的点。
- **PointsMaterial**：用于定义星星的外观，包括颜色、大小和透明度。

#### 2. 生成星星的顶点

通过循环生成随机位置的星星顶点：

```javascript
const starsVertices = [];
for(let i = 0; i < 15000; i++) {
    const x = (Math.random() - 0.5) * 2000;
    const y = (Math.random() - 0.5) * 2000;
    const z = (Math.random() - 0.5) * 2000;
    starsVertices.push(x, y, z);
}
```

- 这里生成了15000个星星的坐标，范围在-1000到1000之间，形成一个立方体的星空效果。

#### 3. 设置星星的几何体属性

将生成的顶点数据添加到几何体中：

```javascript
starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
```

- 使用`setAttribute`方法将顶点数据传递给`BufferGeometry`。

#### 4. 创建星星的点云

使用`THREE.Points`创建星星的点云对象，并将其添加到场景中：

```javascript
const starField = new THREE.Points(starsGeometry, starsMaterial);
scene.add(starField);
```

- `THREE.Points`允许我们将多个点渲染为一个点云，提升渲染效率。

#### 5. 动画效果的实现

在`animateStars`函数中，通过不断更新星星的大小来实现动态效果：

```javascript
function animateStars() {
    brightStarsMaterial.size = 0.8 + Math.sin(Date.now() * 0.001) * 0.2;
    coloredStarsMaterial.size = 0.6 + Math.sin(Date.now() * 0.002) * 0.15;
    
    requestAnimationFrame(animateStars);
}
```

- 使用`Math.sin`函数根据时间变化动态调整星星的大小，产生闪烁的效果。
- `requestAnimationFrame`用于创建一个循环，使得动画流畅进行。

#### 6. 整体动画循环

在`animate`函数中，调用`animateStars`以确保星空效果在每一帧都被更新：

```javascript
function animate() {
    requestAnimationFrame(animate);
    // 其他动画更新逻辑...
    animateStars();
}
```

- 通过不断调用`animate`函数，确保星空的动态效果持续存在。

### 总结

动态星空效果的实现主要依赖于Three.js的点云渲染功能，通过生成大量随机位置的星星顶点，并使用动画函数动态调整星星的大小，创造出一个生动的星空场景。这种方法不仅高效，而且能够在视觉上给人以深邃的感觉。

## 数据绑定.md

### 数据集绑定在DNA模型上的红点实现分析报告

在该HTML文件中，数据集绑定在DNA模型上形成红点的实现主要依赖于Three.js库。以下是具体的代码流程分析：

#### 1. 数据集的准备

首先，定义一个数据集，通常是一个包含多个数据点的数组，每个数据点代表一个DNA序列的特征或位置：

```javascript
const dataPoints = [
    { position: { x: 10, y: 20, z: 30 } },
    { position: { x: -15, y: 25, z: 5 } },
    // ...更多数据点
];
```

- **dataPoints**：数组中的每个对象包含一个`position`属性，表示红点在3D空间中的位置。

#### 2. 创建红点的材质

为红点定义材质，通常使用`PointsMaterial`来创建点的视觉效果：

```javascript
const pointMaterial = new THREE.PointsMaterial({
    color: 0xff0000, // 红色
    size: 5,         // 点的大小
    sizeAttenuation: true
});
```

- **PointsMaterial**：用于定义点的颜色和大小，`sizeAttenuation`属性使得点的大小随着距离的变化而变化。

#### 3. 创建红点的几何体

使用`BufferGeometry`来创建红点的几何体，并将数据集中的每个点添加到几何体中：

```javascript
const pointsGeometry = new THREE.BufferGeometry();
const positions = [];

dataPoints.forEach(dataPoint => {
    const { x, y, z } = dataPoint.position;
    positions.push(x, y, z);
});

pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
```

- **positions**：数组用于存储所有红点的坐标。
- **setAttribute**：将坐标数据传递给`BufferGeometry`，以便在3D场景中渲染。

#### 4. 创建红点的点云

使用`THREE.Points`创建红点的点云对象，并将其添加到场景中：

```javascript
const points = new THREE.Points(pointsGeometry, pointMaterial);
scene.add(points);
```

- **THREE.Points**：将几何体和材质结合，创建可视化的点云。
- **scene.add(points)**：将点云添加到场景中，使其可见。

#### 5. 动态更新红点（可选）

如果需要根据数据集的变化动态更新红点，可以在动画循环中更新几何体的属性：

```javascript
function updatePoints() {
    const newPositions = [];
    dataPoints.forEach(dataPoint => {
        const { x, y, z } = dataPoint.position;
        newPositions.push(x, y, z);
    });
    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
}
```

- **updatePoints**：函数用于更新红点的位置，适用于数据集发生变化的情况。

#### 6. 整体动画循环

在主动画循环中调用更新函数，以确保红点在每一帧都被更新（如果需要）：

```javascript
function animate() {
    requestAnimationFrame(animate);
    // 其他动画更新逻辑...
    updatePoints(); // 如果需要动态更新
}
```

- **requestAnimationFrame**：用于创建一个循环，使得动画流畅进行。

### 总结

数据集绑定在DNA模型上形成红点的实现主要依赖于Three.js的点云渲染功能。通过准备数据集、创建红点的几何体和材质，并将其添加到场景中，成功地在DNA模型上可视化了数据点。这种方法不仅能够有效地展示数据，还可以通过动态更新实现数据的实时可视化。

## 时间旅行 - 倍速.md

### 时间旅行模式倍速实现分析报告

在该代码中，时间旅行模式的倍速控制主要通过以下几个部分实现：

1. **变量定义**：
   - `let playSpeed = 1;`：定义了一个变量 `playSpeed`，用于控制播放速度，初始值为1倍速。

2. **创建速度控制界面**：
   - 在 `createTimeControls` 函数中，创建了一个滑动条（`speedSlider`），用于调整播放速度。滑动条的最小值为1，最大值为5，步长为1。
   - 通过 `speedSlider.oninput` 事件监听器，实时更新 `playSpeed` 的值，并在界面上显示当前速度。

   ```javascript
   const speedSlider = document.createElement('input');
   speedSlider.type = 'range';
   speedSlider.min = '1';
   speedSlider.max = '5';
   speedSlider.value = '1';
   speedSlider.step = '1';
   ```

3. **更新时间线**：
   - 在 `updateTimeline` 函数中，播放逻辑通过 `isPlaying` 和 `playDirection` 控制。每当 `isPlaying` 为 `true` 时，函数会根据 `playSpeed` 的值来决定更新的频率。
   - `if (isPlaying && currentTime - lastUpdateTime >= UPDATE_INTERVAL / playSpeed)` 这一行代码是关键。`UPDATE_INTERVAL` 是一个常量，表示每次更新的时间间隔（1000毫秒），通过 `playSpeed` 进行调整，达到加速或减速的效果。

   ```javascript
   if (isPlaying && currentTime - lastUpdateTime >= UPDATE_INTERVAL / playSpeed) {
       currentTimeIndex += playDirection;
       // 其他逻辑...
   }
   ```

4. **播放控制**：
   - `playDirection` 变量用于控制播放的方向，1表示向前播放，-1表示向后播放。通过 `playDirection` 和 `playSpeed` 的结合，用户可以在不同的速度下前进或后退。

5. **用户交互**：
   - 用户通过滑动条调整播放速度时，`speedSlider.oninput` 事件会被触发，更新 `playSpeed` 的值，并在界面上显示当前速度。这样，用户可以直观地控制时间旅行的速度。

### 总结

时间旅行模式的倍速实现依赖于以下几个关键点：
- 通过滑动条获取用户输入的速度值，并实时更新 `playSpeed`。
- 在 `updateTimeline` 函数中，利用 `playSpeed` 调整时间更新的频率，从而实现加速或减速的效果。
- 结合 `isPlaying` 和 `playDirection` 控制播放的状态和方向，使得用户能够灵活地进行时间旅行。

这种设计使得用户能够在视觉上和交互上都能感受到时间旅行的动态变化，增强了用户体验。

## 时间旅行 - 播放.md

### 时间旅行模式点的顺序展示播放功能分析报告

在该代码中，时间旅行模式的点的顺序展示播放功能主要通过以下几个部分实现：

1. **变量定义**：
   - `let currentTimeIndex = 0;`：定义了一个变量 `currentTimeIndex`，用于跟踪当前展示的时间节点的索引。
   - `let isPlaying = false;`：定义了一个布尔变量 `isPlaying`，用于指示播放状态。
   - `let playDirection = 1;`：定义了一个变量 `playDirection`，用于控制播放的方向，1表示向前播放，-1表示向后播放。

2. **时间更新逻辑**：
   - 在 `updateTimeline` 函数中，播放逻辑通过 `isPlaying` 和 `playDirection` 控制。每当 `isPlaying` 为 `true` 时，函数会根据 `playSpeed` 的值来决定更新的频率。
   - 代码段 `if (isPlaying && currentTime - lastUpdateTime >= UPDATE_INTERVAL / playSpeed)` 是关键。它确保只有在播放状态下，并且经过了足够的时间间隔后，才会更新 `currentTimeIndex`。

   ```javascript
   if (isPlaying && currentTime - lastUpdateTime >= UPDATE_INTERVAL / playSpeed) {
       currentTimeIndex += playDirection;
       // 其他逻辑...
   }
   ```

3. **边界检查**：
   - 在更新 `currentTimeIndex` 后，代码会进行边界检查，确保索引不会超出有效范围：
   ```javascript
   if (currentTimeIndex < 0) currentTimeIndex = 0;
   if (currentTimeIndex >= timelineObjects.children.length) currentTimeIndex = timelineObjects.children.length - 1;
   ```

4. **展示逻辑**：
   - `timelineObjects.children.forEach((object, index) => { object.visible = index <= currentTimeIndex; });` 这一行代码是实现点的顺序展示的核心逻辑。它遍历所有时间节点对象，并根据 `currentTimeIndex` 的值来设置每个对象的可见性。只有索引小于或等于 `currentTimeIndex` 的对象会被显示，其他对象则会被隐藏。

5. **事件详情展示**：
   - 在更新 `currentTimeIndex` 后，代码会检查当前对象是否存在，并且是否有用户数据。如果存在，则调用 `showEventDetails(currentObject.userData);` 来展示该事件的详细信息。

6. **播放控制**：
   - 用户可以通过界面上的按钮（如“播放”、“前进”、“倒退”）来控制播放状态和方向。点击“播放”按钮会切换 `isPlaying` 的状态，并根据当前状态更新按钮文本。
   - “前进”和“倒退”按钮会分别设置 `playDirection` 为1或-1，并将 `isPlaying` 设置为 `true`，开始播放。

### 总结

时间旅行模式的点的顺序展示播放功能依赖于以下几个关键点：
- 通过 `currentTimeIndex` 变量跟踪当前展示的时间节点，并在 `updateTimeline` 函数中根据播放状态和时间间隔更新该索引。
- 使用边界检查确保索引在有效范围内，避免数组越界。
- 通过遍历 `timelineObjects.children`，根据 `currentTimeIndex` 控制每个时间节点的可见性，实现顺序展示。
- 用户通过界面交互控制播放状态和方向，使得时间旅行的体验更加直观和灵活。

这种设计使得用户能够以动态的方式体验时间节点的变化，增强了交互性和可视化效果。

## 时间旅行 - 视角转换.md

### 时间旅行模式视角转换实现分析报告

在该代码中，时间旅行模式的视角转换（播放开始与结束时的流畅转换）主要通过以下几个部分实现：

1. **变量定义**：
   - `let isPlaying = false;`：定义了一个布尔变量 `isPlaying`，用于指示播放状态。
   - `const originalPosition` 和 `const originalRotation`：在播放开始时保存相机的原始位置和旋转状态，以便在播放结束时恢复。

2. **播放按钮逻辑**：
   - 在 `createTimeControls` 函数中，播放按钮的点击事件处理逻辑负责控制视角的转换。点击播放按钮时，会根据当前的播放状态切换 `isPlaying` 的值，并更新按钮文本。

   ```javascript
   playButton.onclick = () => {
       isPlaying = !isPlaying;
       playButton.innerText = isPlaying ? '暂停' : '播放';
       // 视角转换逻辑
   };
   ```

3. **视角转换动画**：
   - 当播放开始时，代码会创建两个动画：一个用于相机位置的转换，另一个用于相机朝向的转换。这两个动画使用 `TWEEN` 库来实现平滑的过渡效果。

   ```javascript
   if (isPlaying) {
       // 保存当前相机位置用于恢复
       const originalPosition = camera.position.clone();
       const originalRotation = camera.rotation.clone();
       
       // 设置目标位置(从下方看向上方)
       const targetPosition = new THREE.Vector3(0, -300, 0);
       const targetLookAt = new THREE.Vector3(0, 0, 0);
       
       // 创建动画
       new TWEEN.Tween(camera.position)
           .to({
               x: targetPosition.x,
               y: targetPosition.y,
               z: targetPosition.z
           }, 2000) // 2秒完成动画
           .easing(TWEEN.Easing.Cubic.InOut)
           .start();
           
       // 创建相机朝向的动画
       new TWEEN.Tween(controls.target)
           .to({
               x: targetLookAt.x,
               y: targetLookAt.y,
               z: targetLookAt.z
           }, 2000)
           .easing(TWEEN.Easing.Cubic.InOut)
           .start();
   }
   ```

4. **播放结束时的视角恢复**：
   - 当播放暂停时，代码会创建一个动画，将相机位置恢复到原始位置。这个过程同样使用 `TWEEN` 库来实现平滑的过渡。

   ```javascript
   } else {
       // 暂停恢复原始视角
       new TWEEN.Tween(camera.position)
           .to({
               x: 100,
               y: 0,
               z: 100
           }, 2000)
           .easing(TWEEN.Easing.Cubic.InOut)
           .start();
   }
   ```

5. **动画更新**：
   - 在 `animate` 函数中，调用 `TWEEN.update()` 来更新所有的动画状态。这确保了在每一帧中，动画的进度都会被更新，从而实现流畅的视角转换。

   ```javascript
   function animate() {
       requestAnimationFrame(animate);
       TWEEN.update();
       // 其他动画逻辑...
   }
   ```

### 总结

时间旅行模式的视角转换实现依赖于以下几个关键点：
- 使用 `isPlaying` 变量控制播放状态，并在播放开始和结束时执行不同的视角转换逻辑。
- 利用 `TWEEN` 库创建平滑的动画效果，分别处理相机位置和朝向的转换。
- 在播放开始时，保存相机的原始位置和旋转状态，以便在播放结束时恢复。
- 在 `animate` 函数中定期更新动画状态，确保视角转换的流畅性。

这种设计使得用户在播放过程中能够体验到自然且流畅的视角变化，增强了时间旅行模式的沉浸感和交互性。

## 画面旋转 - 鼠标与键盘控制.md

### 鼠标左键滑动使画面旋转效果实现分析报告

在该代码中，鼠标左键滑动使画面旋转的效果主要通过以下几个部分实现：

1. **变量定义**：
   - `const raycaster = new THREE.Raycaster();`：创建一个射线投射器，用于检测鼠标与场景中对象的交互。
   - `const mouse = new THREE.Vector2();`：定义一个二维向量，用于存储鼠标在屏幕上的位置。

2. **鼠标移动事件监听**：
   - 通过 `window.addEventListener('mousemove', onMouseMove);` 监听鼠标移动事件，调用 `onMouseMove` 函数来处理鼠标位置的更新和交互逻辑。

3. **鼠标移动处理**：
   - 在 `onMouseMove` 函数中，首先清除之前的定时器，以避免频繁触发事件。
   - 计算鼠标在屏幕上的位置，并将其转换为标准化设备坐标（NDC），范围为[-1, 1]。

   ```javascript
   function onMouseMove(event) {
       clearTimeout(debounceTimer);
       debounceTimer = setTimeout(() => {
           mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
           mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
           raycaster.setFromCamera(mouse, camera);
           // 其他逻辑...
       }, 50);
   }
   ```

4. **射线投射与对象交互**：
   - 使用 `raycaster.setFromCamera(mouse, camera);` 将射线投射器的起点设置为相机，并根据鼠标位置发射射线。
   - 通过 `const intersects = raycaster.intersectObjects(timelineObjects.children);` 检测与场景中对象的交互。如果有交互对象，调用 `showEventDetails(event);` 显示事件详情。

5. **视角旋转逻辑**：
   - 鼠标左键按下时，记录当前鼠标位置，并在 `mousemove` 事件中计算鼠标的移动距离。
   - 通过 `camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);` 实现相机的旋转。这里的 `rotationSpeed` 是一个常量，控制旋转的速度。

6. **相机旋转实现**：
   - 在 `animate` 函数中，处理键盘旋转的逻辑。根据 `keyState` 中的状态，判断是否按下了 Q 或 E 键，分别实现逆时针和顺时针旋转。

   ```javascript
   const rotationSpeed = 0.02; // 调整旋转速度
   if (keyState.q) {
       // Q键逆时针旋转
       camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);
   }
   if (keyState.e) {
       // E键顺时针旋转
       camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -rotationSpeed);
   }
   ```

### 总结

鼠标左键滑动使画面旋转的效果依赖于以下几个关键点：
- 通过 `mousemove` 事件监听器捕获鼠标移动，并计算鼠标在屏幕上的位置。
- 使用射线投射器检测鼠标与场景中对象的交互，增强用户体验。
- 在鼠标左键按下时，记录鼠标位置并计算移动距离，通过相机的 `applyAxisAngle` 方法实现相机的旋转。
- 在 `animate` 函数中，结合键盘事件处理，实现更灵活的视角控制。

这种设计使得用户能够通过简单的鼠标操作实现画面的旋转，增强了交互性和沉浸感。

# biological-evolution-force-2D

## 力导向图.md

# 力导向图实现分析报告

## 概述
力导向图是一种常用的数据可视化方式，通常用于展示节点之间的关系。该实现使用了 D3.js 库，结合 SVG 技术，创建了一个交互式的力导向图。以下是对代码流程的详细分析。

## 代码流程分析

### 1. HTML 结构
```html
<!DOCTYPE html>
<html lang="zh">
<head>
    ...
</head>
<body>
    <div id="background-container" class="background-image-container"></div>
    <div class="controls">...</div>
    <div id="container">
        <div id="graph"></div>
        <div id="magnifier"></div>
    </div>
    <script>...</script>
</body>
</html>
```
- **HTML 结构**：包含一个背景容器、控制面板和图形容器。控制面板提供了用户交互的按钮。

### 2. 初始化 SVG 容器
```javascript
let width = window.innerWidth;
let height = window.innerHeight;

const svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height);
```
- **SVG 容器**：根据窗口大小创建 SVG 元素，用于绘制图形。

### 3. 添加背景矩形
```javascript
svg.append("rect")
    .attr("class", "background")
    .attr("width", "100%")
    .attr("height", "100%")
    .attr("fill", "transparent");
```
- **背景矩形**：添加一个透明的矩形作为背景，便于实现拖拽功能。

### 4. 定义力导向模拟
```javascript
const simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(d => d.id).distance(100))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("collide", d3.forceCollide().radius(50))
    .force("center", d3.forceCenter(0, 0).strength(0.1))
    .force("radial", d3.forceRadial(d => d.depth * 180, 0, 0).strength(0.8));
```
- **力导向模拟**：定义了多个力，包括链接力、斥力、碰撞力、中心力和径向力。每种力的参数可以调整，以实现不同的视觉效果。

### 5. 数据处理与树布局
```javascript
let root = d3.hierarchy(treeData);
root.children.forEach(collapse);
```
- **数据处理**：使用 D3 的层次结构函数将数据转换为树形结构，并初始化折叠状态。

### 6. 更新函数
```javascript
function update(source) {
    ...
    const nodes = root.descendants();
    const links = root.links();
    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(1).restart();
    ...
}
```
- **更新函数**：计算节点和链接的布局，更新力导向模拟的节点和链接数据，并重启模拟。

### 7. 节点和链接的绘制
```javascript
const node = g.selectAll(".node")
    .data(nodes, d => d.id || (d.id = ++i));

const link = g.selectAll(".link")
    .data(links, d => d.target.id);
```
- **节点和链接的绑定**：将数据绑定到 SVG 元素，使用 `enter`、`update` 和 `exit` 模式处理节点和链接的添加、更新和删除。

### 8. 交互功能
```javascript
nodeEnter.on("click", click)
    .on("mouseover", showNodeInfo)
    .on("mouseout", hideNodeInfo);
```
- **交互功能**：为节点添加点击、鼠标悬停和移出事件，提供信息展示和节点展开/收起功能。

### 9. 拖拽功能
```javascript
const dragHandler = d3.drag()
    .subject(function (event, d) {
        return { x: d.x, y: d.y };
    })
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended);
```
- **拖拽功能**：实现节点的拖拽，更新节点位置并重新计算连接线。

### 10. 窗口大小调整
```javascript
window.addEventListener('resize', debounce(() => {
    width = window.innerWidth;
    height = window.innerHeight;
    svg.attr("width", width).attr("height", height);
    update(root);
}, 250));
```
- **窗口大小调整**：监听窗口大小变化，重新设置 SVG 尺寸并更新图形。

## 总结
该力导向图的实现通过 D3.js 提供的强大功能，结合 SVG 技术，创建了一个动态、交互性强的可视化图形。通过力导向模拟、数据绑定、事件处理等步骤，用户可以直观地理解节点之间的关系，并进行交互操作。

## 数据绑定.md

# 数据绑定到力导向图的功能实现分析报告

## 概述
在力导向图中，数据绑定是将数据与图形元素（如节点和链接）关联的过程。D3.js 提供了强大的数据绑定功能，使得图形可以根据数据的变化动态更新。以下是对数据绑定到力导向图的具体实现流程的详细分析。

## 代码流程分析

### 1. 数据准备
在力导向图的实现中，首先需要准备好数据。数据通常以树形结构或图形结构的形式存在，包含节点及其之间的关系。

```javascript
let root = d3.hierarchy(treeData);
```

- **数据结构**：使用 D3 的 `hierarchy` 函数将原始数据 `treeData` 转换为层次结构，便于后续处理。

### 2. 计算节点和链接
在更新函数中，计算出当前的节点和链接。

```javascript
const nodes = root.descendants();
const links = root.links();
```

- **节点和链接的计算**：`descendants()` 方法返回树的所有节点，`links()` 方法返回节点之间的链接关系。这些数据将用于后续的绑定和绘制。

### 3. 数据绑定
使用 D3 的数据绑定方法将计算出的节点和链接与 SVG 元素进行绑定。

```javascript
const node = g.selectAll(".node")
    .data(nodes, d => d.id || (d.id = ++i));

const link = g.selectAll(".link")
    .data(links, d => d.target.id);
```

- **节点绑定**：`selectAll(".node")` 选择所有节点元素，`.data(nodes)` 将节点数据绑定到这些元素上。第二个参数是一个键函数，用于唯一标识每个节点。
- **链接绑定**：`selectAll(".link")` 选择所有链接元素，`.data(links)` 将链接数据绑定到这些元素上，使用目标节点的 ID 作为唯一标识。

### 4. 处理进入、更新和退出
D3.js 提供了 `enter`、`update` 和 `exit` 模式来处理数据绑定后的元素状态。

#### 4.1 处理节点的进入
```javascript
const nodeEnter = node.enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.x0},${source.y0})`)
    .on("click", click)
    .on("mouseover", showNodeInfo)
    .on("mouseout", hideNodeInfo);
```

- **进入选择**：`node.enter()` 返回一个进入选择集，表示新绑定的数据。
- **添加节点元素**：使用 `append("g")` 创建新的 `<g>` 元素，作为节点的容器。
- **设置属性和事件**：为新节点设置类名、初始位置，并绑定事件处理函数。

#### 4.2 添加节点的图形元素
```javascript
nodeEnter.append("circle")
    .attr("r", 12)
    .style("fill", d => getNodeColor(d))
    .style("cursor", "pointer");

nodeEnter.append("text")
    .attr("dy", ".31em")
    .attr("x", d => d._children ? -10 : 10)
    .attr("text-anchor", d => d._children ? "end" : "start")
    .text(d => d.data.name);
```

- **添加圆形和文本**：为每个新节点添加一个圆形和文本元素，设置其半径、填充颜色和文本内容。

#### 4.3 更新节点
```javascript
const nodeUpdate = node.merge(nodeEnter);

nodeUpdate.transition()
    .duration(750)
    .attr("transform", d => `translate(${d.x},${d.y})`);
```

- **合并选择**：`node.merge(nodeEnter)` 将进入选择与现有节点合并，形成更新选择。
- **更新位置**：使用过渡效果更新节点的位置。

#### 4.4 处理节点的退出
```javascript
const nodeExit = node.exit()
    .transition()
    .duration(750)
    .attr("transform", d => `translate(${source.x},${source.y})`)
    .remove();
```

- **退出选择**：`node.exit()` 返回退出选择集，表示不再需要的节点。
- **过渡效果**：为退出的节点添加过渡效果，最后将其从 DOM 中移除。

### 5. 链接的处理
链接的处理与节点类似，使用 `enter`、`update` 和 `exit` 模式。

#### 5.1 处理链接的进入
```javascript
const linkEnter = link.enter()
    .insert("path", "g")
    .attr("class", "link")
    .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
    });
```

- **插入链接元素**：使用 `insert("path", "g")` 在节点组中插入新的路径元素，表示链接。
- **设置初始路径**：使用 `diagonal` 函数设置初始路径。

#### 5.2 更新链接
```javascript
const linkUpdate = link.merge(linkEnter);

linkUpdate.transition()
    .duration(750)
    .attr("d", diagonal);
```

- **合并选择**：将进入选择与现有链接合并。
- **更新路径**：使用过渡效果更新链接的路径。

#### 5.3 处理链接的退出
```javascript
const linkExit = link.exit()
    .transition()
    .duration(750)
    .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
    })
    .remove();
```

- **退出选择**：处理不再需要的链接，添加过渡效果并移除。

### 6. 力导向模拟的更新
```javascript
simulation.nodes(nodes);
simulation.force("link").links(links);
simulation.alpha(1).restart();
```

- **更新模拟**：将新的节点和链接数据传递给力导向模拟，重启模拟以计算新的位置。

## 总结
数据绑定到力导向图的功能通过 D3.js 的数据绑定机制实现。通过计算节点和链接，使用 `enter`、`update` 和 `exit` 模式处理元素的添加、更新和删除，结合力导向模拟，动态地展示了节点之间的关系。这种方法使得图形能够根据数据的变化实时更新，提供了良好的用户交互体验。

## 树状JSON数据转化为力导向图.md

### 报告：树状 JSON 数据转化为力导向图的实现分析

#### 1. 数据结构概述
在力导向图中，通常需要将数据结构转换为包含节点（nodes）和连接（links）的格式。然而，给定的数据集是树状的 JSON 数据，没有明确的节点和连接结构。为了在 D3.js 中实现力导向图，需要将树状 JSON 数据转换为适合 D3.js 的格式。

#### 2. 数据转换流程
以下是将树状 JSON 数据转换为 D3.js 力导向图所需的步骤：

##### 2.1 定义树状数据
树状数据通常具有以下结构：
```json
{
    "name": "根节点",
    "children": [
        {
            "name": "子节点1",
            "children": [...]
        },
        {
            "name": "子节点2",
            "children": [...]
        }
    ]
}
```
在这个结构中，每个节点都有一个名称和可能的子节点。

##### 2.2 使用 D3.js 的层次结构
D3.js 提供了 `d3.hierarchy()` 方法来处理树状数据。该方法将树状 JSON 数据转换为 D3.js 可用的层次结构对象。

```javascript
let root = d3.hierarchy(treeData);
```
这里，`treeData` 是原始的树状 JSON 数据。`root` 变量现在包含了 D3.js 的层次结构对象。

##### 2.3 计算节点和连接
在 D3.js 中，力导向图需要节点和连接信息。通过调用 `tree()` 方法，可以计算出节点的位置和连接关系。

```javascript
const tree = d3.tree().size([360, Math.min(width, height) / 2]);
tree(root);
```
`tree(root)` 会更新 `root` 对象，计算出每个节点的 `x` 和 `y` 坐标。

##### 2.4 创建节点和连接
在更新函数中，使用 `root.descendants()` 获取所有节点，并使用 `root.links()` 获取连接信息。

```javascript
const nodes = root.descendants();
const links = root.links();
```
- `nodes` 包含了所有节点的信息。
- `links` 包含了每个连接的源节点和目标节点。

##### 2.5 绑定数据到 SVG 元素
接下来，将节点和连接数据绑定到 SVG 元素上，以便在图形中可视化。

```javascript
const node = g.selectAll(".node")
    .data(nodes, d => d.id || (d.id = ++i));

const link = g.selectAll(".link")
    .data(links, d => d.target.id);
```
这里，`g` 是 SVG 的组元素，`.node` 和 `.link` 是节点和连接的 CSS 类。

##### 2.6 创建和更新节点
对于新节点，使用 `enter()` 方法创建 SVG 元素，并设置其属性和事件处理程序。

```javascript
const nodeEnter = node.enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.x0},${source.y0})`)
    .on("click", click);
```
在这里，`click` 是处理节点点击事件的函数。

##### 2.7 创建和更新连接
连接的创建和更新类似于节点的处理，使用 `enter()` 和 `merge()` 方法来处理连接的进入和更新。

```javascript
const linkEnter = link.enter()
    .insert("path", "g")
    .attr("class", "link")
    .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
    });
```
`diagonal` 函数用于生成连接的路径。

#### 3. 交互和动画
在更新节点和连接后，使用 D3.js 的过渡效果来实现动画效果，使得图形在数据更新时更加平滑。

```javascript
nodeUpdate.transition()
    .duration(750)
    .attr("transform", d => `translate(${d.x},${d.y})`);

linkUpdate.transition()
    .duration(750)
    .attr("d", diagonal);
```

#### 4. 总结
通过以上步骤，树状 JSON 数据被成功转换为 D3.js 力导向图所需的节点和连接格式。使用 D3.js 的层次结构和力导向模拟功能，可以实现动态和交互式的可视化效果。整个过程涉及数据的解析、计算节点和连接、以及在 SVG 中的可视化展示。

## 鼠标左击节点.md

# 鼠标点击展开/收起节点功能实现分析报告

## 概述
在力导向图中，鼠标点击展开或收起节点的功能使得用户能够更好地浏览和管理复杂的树形结构。该功能通过事件监听和数据结构的动态更新实现。以下是对该功能实现的具体代码流程的详细分析。

## 代码流程分析

### 1. 事件绑定
在节点的创建过程中，为每个节点绑定点击事件。

```javascript
nodeEnter.on("click", click);
```

- **事件绑定**：使用 `on("click", click)` 为每个新创建的节点添加点击事件监听器。当用户点击节点时，触发 `click` 函数。

### 2. 点击事件处理函数
`click` 函数负责处理节点的展开和收起逻辑。

```javascript
function click(event, d) {
    event.stopPropagation();
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
}
```

#### 2.1 阻止事件传播
```javascript
event.stopPropagation();
```

- **阻止事件传播**：确保在节点上点击时，不会触发其他父元素的事件，避免不必要的交互。

#### 2.2 判断节点状态
```javascript
if (d.children) {
    d._children = d.children;
    d.children = null;
} else {
    d.children = d._children;
    d._children = null;
}
```

- **判断节点状态**：检查当前节点是否有子节点（`children`）。如果有子节点，则将其存储到 `_children` 属性中，并将 `children` 设置为 `null`，表示该节点被收起；如果没有子节点，则将 `_children` 恢复到 `children`，表示该节点被展开。

### 3. 更新函数
在点击事件处理完后，调用 `update` 函数以重新渲染图形。

```javascript
update(d);
```

- **更新图形**：调用 `update` 函数，传入当前节点 `d`，以更新图形的状态和布局。

### 4. 更新函数的实现
`update` 函数负责重新计算节点和链接的布局，并更新图形。

```javascript
function update(source) {
    ...
    const nodes = root.descendants();
    const links = root.links();
    ...
}
```

#### 4.1 计算节点和链接
```javascript
const nodes = root.descendants();
const links = root.links();
```

- **计算节点和链接**：使用 `descendants()` 方法获取当前树的所有节点，使用 `links()` 方法获取节点之间的链接关系。这些数据将用于后续的绑定和绘制。

#### 4.2 数据绑定
```javascript
const node = g.selectAll(".node")
    .data(nodes, d => d.id || (d.id = ++i));

const link = g.selectAll(".link")
    .data(links, d => d.target.id);
```

- **数据绑定**：将计算出的节点和链接与 SVG 元素进行绑定，使用 `enter`、`update` 和 `exit` 模式处理元素的添加、更新和删除。

### 5. 处理节点的进入、更新和退出
在 `update` 函数中，处理节点和链接的进入、更新和退出。

#### 5.1 处理节点的进入
```javascript
const nodeEnter = node.enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.x0},${source.y0})`)
    .on("click", click);
```

- **进入选择**：为新绑定的数据创建新的 `<g>` 元素，设置类名和初始位置，并绑定点击事件。

#### 5.2 更新节点
```javascript
const nodeUpdate = node.merge(nodeEnter);

nodeUpdate.transition()
    .duration(750)
    .attr("transform", d => `translate(${d.x},${d.y})`);
```

- **合并选择**：将进入选择与现有节点合并，使用过渡效果更新节点的位置。

#### 5.3 处理节点的退出
```javascript
const nodeExit = node.exit()
    .transition()
    .duration(750)
    .attr("transform", d => `translate(${source.x},${source.y})`)
    .remove();
```

- **退出选择**：处理不再需要的节点，添加过渡效果并移除。

### 6. 链接的处理
链接的处理与节点类似，使用 `enter`、`update` 和 `exit` 模式。

#### 6.1 处理链接的进入
```javascript
const linkEnter = link.enter()
    .insert("path", "g")
    .attr("class", "link")
    .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
    });
```

- **插入链接元素**：在节点组中插入新的路径元素，表示链接，并设置初始路径。

#### 6.2 更新链接
```javascript
const linkUpdate = link.merge(linkEnter);

linkUpdate.transition()
    .duration(750)
    .attr("d", diagonal);
```

- **合并选择**：将进入选择与现有链接合并，使用过渡效果更新链接的路径。

#### 6.3 处理链接的退出
```javascript
const linkExit = link.exit()
    .transition()
    .duration(750)
    .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
    })
    .remove();
```

- **退出选择**：处理不再需要的链接，添加过渡效果并移除。

## 总结
鼠标点击展开/收起节点的功能通过事件监听、数据结构的动态更新和图形的重新渲染实现。通过为每个节点绑定点击事件，判断节点的状态并更新数据，调用更新函数重新渲染图形，用户可以方便地浏览和管理树形结构。这种实现方式使得力导向图的交互性增强，提升了用户体验。

## 鼠标悬停.md

# 鼠标悬停展示详细信息效果实现分析报告

## 概述
在力导向图中，鼠标悬停展示详细信息的效果是通过事件监听和动态更新 DOM 元素来实现的。该功能使用户能够在与图形交互时获取更多信息，增强了可视化的交互性。以下是对该效果实现的具体代码流程的详细分析。

## 代码流程分析

### 1. 事件绑定
在节点的创建过程中，为每个节点绑定鼠标悬停和移出事件。

```javascript
nodeEnter.on("mouseover", showNodeInfo)
    .on("mouseout", hideNodeInfo);
```

- **事件绑定**：使用 `on("mouseover", showNodeInfo)` 和 `on("mouseout", hideNodeInfo)` 为每个新创建的节点添加事件监听器。当鼠标悬停在节点上时，触发 `showNodeInfo` 函数；当鼠标移出节点时，触发 `hideNodeInfo` 函数。

### 2. 显示节点信息的函数
`showNodeInfo` 函数负责在鼠标悬停时展示节点的详细信息。

```javascript
function showNodeInfo(event, d) {
    event.stopPropagation();

    const infoContent = document.querySelector('.info-content');
    const backgroundContainer = document.getElementById('background-container');

    let html = '';

    if (d.data.name) {
        html += `<p><span class="info-label">名称：</span>${d.data.name}</p>`;
    }

    if (d.data.time) {
        html += `<p><span class="info-label">时间：</span>${d.data.time}</p>`;
    }

    if (d.data.description) {
        html += `<p><span class="info-label">描述：</span>${d.data.description}</p>`;
    }

    infoContent.innerHTML = html || '<p>该节点没有额外信息</p>';

    if (d.data.src) {
        const imagePath = d.data.src;
        backgroundContainer.style.cssText = `
            background-image: url('${imagePath}');
            background-size: 100% 100% !important;
            background-position: center;
            background-repeat: no-repeat;
            z-index: -1;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
        `;
        requestAnimationFrame(() => {
            backgroundContainer.classList.add('visible');
        });
    }

    const currentNode = d3.select(event.currentTarget || findNodeElement(d));
    currentNode
        .select('circle')
        .transition()
        .duration(200)
        .attr('r', 16)
        .style('filter', 'drop-shadow(0 0 5px rgba(0,0,0,0.3))');
}
```

#### 2.1 阻止事件传播
```javascript
event.stopPropagation();
```
- **阻止事件传播**：确保在节点上悬停时，不会触发其他父元素的事件。

#### 2.2 获取信息面板和背景容器
```javascript
const infoContent = document.querySelector('.info-content');
const backgroundContainer = document.getElementById('background-container');
```
- **获取 DOM 元素**：选择用于显示信息的内容区域和背景容器。

#### 2.3 构建信息内容
```javascript
let html = '';

if (d.data.name) {
    html += `<p><span class="info-label">名称：</span>${d.data.name}</p>`;
}

if (d.data.time) {
    html += `<p><span class="info-label">时间：</span>${d.data.time}</p>`;
}

if (d.data.description) {
    html += `<p><span class="info-label">描述：</span>${d.data.description}</p>`;
}

infoContent.innerHTML = html || '<p>该节点没有额外信息</p>';
```
- **构建信息内容**：根据节点的数据构建 HTML 字符串，包含名称、时间和描述等信息，并将其插入到信息面板中。

#### 2.4 设置背景图像
```javascript
if (d.data.src) {
    const imagePath = d.data.src;
    backgroundContainer.style.cssText = `
        background-image: url('${imagePath}');
        background-size: 100% 100% !important;
        background-position: center;
        background-repeat: no-repeat;
        z-index: -1;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
    `;
    requestAnimationFrame(() => {
        backgroundContainer.classList.add('visible');
    });
}
```
- **设置背景图像**：如果节点数据中包含图像路径，则将该图像设置为背景，并使背景容器可见。

#### 2.5 高亮当前节点
```javascript
const currentNode = d3.select(event.currentTarget || findNodeElement(d));
currentNode
    .select('circle')
    .transition()
    .duration(200)
    .attr('r', 16)
    .style('filter', 'drop-shadow(0 0 5px rgba(0,0,0,0.3))');
```
- **高亮节点**：通过选择当前节点的圆形元素，增加其半径并添加阴影效果，以突出显示。

### 3. 隐藏节点信息的函数
`hideNodeInfo` 函数负责在鼠标移出节点时隐藏信息。

```javascript
function hideNodeInfo(event, d) {
    const infoContent = document.querySelector('.info-content');
    const backgroundContainer = document.getElementById('background-container');

    infoContent.innerHTML = '<p>将鼠标悬停在节点上查看详细信息</p>';
    backgroundContainer.classList.remove('visible');
    setTimeout(() => {
        if (!backgroundContainer.classList.contains('visible')) {
            backgroundContainer.style.backgroundImage = 'none';
        }
    }, 300);

    d3.select(event.currentTarget)
        .select('circle')
        .transition()
        .duration(200)
        .attr('r', 12)
        .style('filter', null);
}
```

#### 3.1 重置信息内容
```javascript
infoContent.innerHTML = '<p>将鼠标悬停在节点上查看详细信息</p>';
```
- **重置信息内容**：在隐藏信息时，将信息面板的内容重置为提示信息。

#### 3.2 隐藏背景图像
```javascript
backgroundContainer.classList.remove('visible');
setTimeout(() => {
    if (!backgroundContainer.classList.contains('visible')) {
        backgroundContainer.style.backgroundImage = 'none';
    }
}, 300);
```
- **隐藏背景图像**：移除背景容器的可见性，并在一定时间后将背景图像设置为 `none`，以避免占用空间。

#### 3.3 恢复节点样式
```javascript
d3.select(event.currentTarget)
    .select('circle')
    .transition()
    .duration(200)
    .attr('r', 12)
    .style('filter', null);
```
- **恢复节点样式**：将节点的圆形元素的半径恢复到原始值，并移除阴影效果。

## 总结
鼠标悬停展示详细信息的效果通过事件监听、DOM 操作和样式更新实现。通过为每个节点绑定鼠标悬停和移出事件，动态更新信息面板和背景图像，增强了用户与力导向图的交互体验。这种实现方式使得用户能够快速获取节点的详细信息，提升了可视化的实用性和美观性。

# biological-evolution-star-3D

## 树状模型.md

### 报告：树状模型的实现分析

在该HTML文件中，树状模型的实现主要依赖于Three.js库，通过创建节点（球体）和连接线（曲线）来构建一个可视化的生物演化网络。以下是代码流程的详细分析：

#### 1. 初始化参数和场景

- **网络参数**：在`networkParameters`对象中定义了节点的大小、线的长度、高度差等参数。
  
```javascript
let networkParameters = {
    heightStep: 25,     // 高度差
    radius: 255,        // 线长度
    levelHeight: 25,    // 垂直间距
    nodeSize: 2.5       // 节点大小
};
```

- **初始化函数**：`init()`函数设置了Three.js的场景、相机、渲染器和光源，并调用`createStarField()`和`createNetworkVisualization()`来创建星空和网络可视化。

#### 2. 创建网络可视化

- **`createNetworkVisualization()`函数**：该函数是构建树状模型的核心，主要步骤如下：

1. **定义基准角度和高度偏移**：
   - 使用`categoryBaseAngles`和`categoryHeightOffset`对象来定义不同地质年代的基准角度和高度偏移量。

2. **创建节点**：
   - 通过`createNodes()`函数递归地创建节点和连接线。该函数接受数据、位置、层级、角度等参数。

#### 3. 创建节点

- **`createNodes(data, position, level, angle, parentColor, baseAngle)`**：
  - **节点颜色**：根据层级和数据名称选择颜色。
  - **节点几何体**：使用`THREE.SphereGeometry`创建球体作为节点。
  - **节点位置**：根据父节点的位置和计算的角度来确定子节点的位置。

```javascript
const nodeGeometry = new THREE.SphereGeometry(networkParameters.nodeSize, 32, 32);
const nodeMaterial = new THREE.MeshPhongMaterial({ color: color, ... });
const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
node.position.copy(position);
networkGroup.add(node);
```

#### 4. 创建连接线

- **连接线的创建**：在`createNodes()`函数中，使用`createCurvedLine()`函数为每对父子节点创建连接线。

```javascript
const connection = createCurvedLine(position, childPosition, color, controlPointOffset);
networkGroup.add(connection);
```

- **`createCurvedLine(startPoint, endPoint, color, controlPointOffset)`**：
  - 计算控制点以创建曲线，使用`THREE.QuadraticBezierCurve3`生成连接线的几何体。

```javascript
const curve = new THREE.QuadraticBezierCurve3(startPoint, controlPoint, endPoint);
const points = curve.getPoints(50);
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const line = new THREE.Line(geometry, material);
```

#### 5. 动画效果

- **节点动画**：在`animateNetwork()`函数中，为节点添加呼吸效果，通过调整节点的缩放比例来实现。

```javascript
child.scale.x = 1 + Math.sin(Date.now() * 0.001) * 0.2;
```

#### 6. 交互功能

- **鼠标事件**：通过`onMouseClick()`和`onMouseMove()`函数实现节点的高亮和信息显示。当用户点击节点时，显示该节点的详细信息，并在鼠标移动时高亮显示节点。

```javascript
const intersects = raycaster.intersectObjects(networkGroup.children.filter(child => child instanceof THREE.Mesh));
```

### 总结

该代码通过Three.js库实现了一个动态的树状模型，利用节点和连接线的组合来展示生物演化的网络结构。通过递归创建节点和连接线，结合动画和交互功能，使得可视化效果生动且易于理解。

## 模型参数动态调整.md

### 报告：页面参数调整与模型变化的实现分析

在该项目中，用户可以通过调整页面中的参数来动态改变树状模型的外观和结构。以下是具体代码流程的详细分析：

#### 1. 参数输入元素的设置

- **HTML元素**：在页面中，使用`<input>`、`<select>`等元素来让用户输入或选择参数。这些元素通常会绑定到JavaScript事件，以便在用户更改参数时触发相应的函数。

```html
<input type="number" id="nodeSize" value="2.5" />
<select id="colorScheme">
    <option value="default">默认</option>
    <option value="vibrant">鲜艳</option>
</select>
```

#### 2. 事件监听器的添加

- **事件绑定**：在JavaScript中，使用`addEventListener`方法为这些输入元素添加事件监听器，以便在用户更改参数时调用更新函数。

```javascript
document.getElementById('nodeSize').addEventListener('input', updateNodeSize);
document.getElementById('colorScheme').addEventListener('change', updateColorScheme);
```

#### 3. 更新函数的实现

- **`updateNodeSize()`函数**：该函数获取用户输入的节点大小，并更新模型中所有节点的大小。

```javascript
function updateNodeSize() {
    const newSize = parseFloat(document.getElementById('nodeSize').value);
    networkGroup.children.forEach(node => {
        if (node instanceof THREE.Mesh) {
            node.scale.set(newSize, newSize, newSize);
        }
    });
}
```

- **`updateColorScheme()`函数**：该函数根据用户选择的颜色方案更新模型中节点的颜色。

```javascript
function updateColorScheme() {
    const selectedScheme = document.getElementById('colorScheme').value;
    networkGroup.children.forEach(node => {
        if (node instanceof THREE.Mesh) {
            node.material.color.set(selectedScheme === 'vibrant' ? 0xff0000 : 0x00ff00);
        }
    });
}
```

#### 4. 动态渲染模型

- **渲染循环**：在`animate()`函数中，调用`renderer.render()`来更新场景的渲染。每次参数更新后，模型会在下一帧中自动反映这些变化。

```javascript
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
```

#### 5. 交互反馈

- **实时反馈**：通过上述事件监听器和更新函数，用户在调整参数时，模型会立即反映出这些变化，提供了良好的交互体验。

### 总结

该项目通过HTML输入元素和JavaScript事件监听器实现了用户对模型参数的动态调整。通过更新函数，用户的输入能够实时影响模型的外观和结构，结合Three.js的渲染机制，使得模型的变化在页面中即时可见。这种设计增强了用户的交互体验，使得模型的可视化更加灵活和直观。

## 相机视角过渡.md

### 报告：点击节点时相机视角转移到节点旁并旋转角度朝向根节点的实现分析

#### 1. 事件监听
首先，为每个节点添加鼠标点击事件的监听器，以便在点击时触发相机视角的变化。

```javascript
nodes.forEach(node => {
    node.addEventListener('click', function(event) {
        moveCameraToNode(node); // 点击节点后移动相机
    });
});
```

#### 2. 获取节点位置
在事件处理函数中，需要获取被点击节点的位置，以便相机可以移动到该位置。可以使用节点的 `getBoundingClientRect` 方法来获取节点的坐标。

```javascript
function getNodePosition(node) {
    const rect = node.getBoundingClientRect();
    return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        z: 0 // 假设在2D平面上，z轴为0
    };
}
```

#### 3. 移动相机
接下来，定义一个函数来移动相机到指定位置。假设使用的是一个 3D 渲染库（如 Three.js），可以通过设置相机的位置来实现。

```javascript
function moveCameraToNode(node) {
    const position = getNodePosition(node);
    camera.position.set(position.x, position.y, camera.position.z + 5); // 移动相机到节点旁
    camera.lookAt(rootNode.position); // 使相机朝向根节点
}
```

#### 4. 旋转相机
为了实现相机的旋转效果，可以使用 `Tween.js` 或其他动画库来平滑过渡相机的角度。可以设置相机的旋转角度，使其朝向根节点。

```javascript
function rotateCameraToRoot() {
    const targetRotation = new THREE.Vector3(0, Math.atan2(rootNode.position.x, rootNode.position.z), 0); // 计算朝向根节点的旋转角度
    new TWEEN.Tween(camera.rotation)
        .to(targetRotation, 1000) // 动画持续时间为1000毫秒
        .start();
}
```

#### 5. 整合代码
将上述步骤整合在一起，形成完整的代码流程。

```javascript
nodes.forEach(node => {
    node.addEventListener('click', function(event) {
        moveCameraToNode(node); // 移动相机到节点旁
        rotateCameraToRoot(); // 旋转相机朝向根节点
    });
});
```

#### 6. 总结
通过上述步骤，可以实现点击节点时相机视角转移到节点旁并旋转角度朝向根节点的效果。关键在于事件监听、获取节点位置、移动相机以及旋转相机的实现。使用动画库可以使相机的移动和旋转更加平滑和自然。

## 节点光圈高亮.md

### 报告：鼠标点击节点后节点增加黄圈高亮的实现分析

#### 1. 事件监听
首先，需要为节点添加鼠标点击事件的监听器。通常使用 JavaScript 的 `addEventListener` 方法来实现。

```javascript
node.addEventListener('click', function(event) {
    // 处理点击事件
});
```

#### 2. 高亮效果的实现
在事件处理函数中，点击节点后，需要为后续节点添加高亮效果。可以通过创建一个新的元素（如一个 `<div>` 或 `<span>`）来实现黄圈的效果。

```javascript
function highlightNextNode(node) {
    const nextNode = node.nextElementSibling; // 获取下一个节点
    if (nextNode) {
        const highlightCircle = document.createElement('div'); // 创建高亮圈
        highlightCircle.className = 'highlight-circle'; // 添加类名以便于样式设置
        nextNode.appendChild(highlightCircle); // 将高亮圈添加到下一个节点
    }
}
```

#### 3. CSS 样式
为了使高亮圈可见，需要在 CSS 中定义其样式。可以设置其大小、颜色和形状。

```css
.highlight-circle {
    width: 20px; /* 圆圈的宽度 */
    height: 20px; /* 圆圈的高度 */
    border-radius: 50%; /* 使其成为圆形 */
    background-color: yellow; /* 圆圈的颜色 */
    position: absolute; /* 绝对定位 */
    top: 50%; /* 垂直居中 */
    left: 50%; /* 水平居中 */
    transform: translate(-50%, -50%); /* 使圆圈中心对齐 */
}
```

#### 4. 整合代码
将上述步骤整合在一起，形成完整的代码流程。

```javascript
// 假设我们有多个节点
const nodes = document.querySelectorAll('.node');

nodes.forEach(node => {
    node.addEventListener('click', function(event) {
        highlightNextNode(node); // 点击节点后高亮下一个节点
    });
});
```

#### 5. 总结
通过上述步骤，可以实现鼠标点击节点后，后续节点增加黄圈高亮的效果。关键在于事件监听、动态创建高亮元素以及相应的 CSS 样式设置。

# biological-evolution-tree-2D

## 搜索节点并平滑过渡.md

### 搜索节点并平滑过渡到节点位置实现分析报告

#### 1. HTML 结构

搜索功能的 HTML 结构主要由一个输入框和一个结果显示区域组成。用户可以在输入框中输入搜索关键词，匹配的节点将显示在结果区域。

```html
<div class="search-container">
    <input type="text" id="search-input" placeholder="搜索节点...">
    <div id="search-results"></div>
</div>
```

#### 2. 事件监听

搜索功能的核心在于为输入框添加事件监听器，以便在用户输入时实时过滤和显示匹配的节点。

```javascript
searchInput.addEventListener('input', function(e) {
    const searchTerm = e.target.value.trim().toLowerCase();
    if (!searchTerm) {
        searchResults.innerHTML = '';
        return;
    }
    // 过滤和显示搜索结果的逻辑
});
```

- `searchInput.addEventListener('input', function(e) {...})`：为搜索输入框添加 `input` 事件监听器，当用户输入内容时触发该事件。
- `const searchTerm = e.target.value.trim().toLowerCase();`：获取用户输入的搜索关键词，并进行处理（去除空格并转换为小写）。

#### 3. 匹配节点

在事件处理函数中，使用过滤逻辑来匹配节点名称。

```javascript
const matches = allNodes.filter(node => 
    node.data.name && node.data.name.toLowerCase().includes(searchTerm)
);
```

- `allNodes.filter(...)`：遍历所有节点，筛选出名称包含搜索关键词的节点。
- `node.data.name.toLowerCase().includes(searchTerm)`：检查节点名称是否包含用户输入的关键词。

#### 4. 显示搜索结果

将匹配的节点结果显示在搜索结果区域。

```javascript
searchResults.innerHTML = matches
    .map(node => `
        <div class="search-result-item" data-node-id="${node.data.name}">
            ${node.data.name}
        </div>
    `).join('');
```

- `searchResults.innerHTML = matches.map(...).join('');`：将匹配的节点转换为 HTML 元素，并更新搜索结果区域的内容。
- 每个搜索结果项都包含一个 `data-node-id` 属性，用于标识节点。

#### 5. 点击搜索结果

为每个搜索结果项添加点击事件，以便用户点击后可以高亮显示对应的节点并平滑过渡到该节点的位置。

```javascript
document.querySelectorAll('.search-result-item').forEach(item => {
    item.addEventListener('click', function() {
        const nodeId = this.dataset.nodeId;
        const targetNode = allNodes.find(n => n.data.name === nodeId);
        if (targetNode) {
            highlightPathToRoot(targetNode);
            scrollToNode(targetNode);
        }
    });
});
```

- `document.querySelectorAll('.search-result-item').forEach(item => {...})`：为每个搜索结果项添加点击事件监听器。
- `const targetNode = allNodes.find(n => n.data.name === nodeId);`：根据点击的节点 ID 查找对应的节点。
- `highlightPathToRoot(targetNode);`：调用高亮路径函数，突出显示从目标节点到根节点的路径。
- `scrollToNode(targetNode);`：调用平滑滚动函数，平滑过渡到目标节点的位置。

#### 6. 高亮路径函数

高亮路径的实现通过遍历从目标节点到根节点的路径，并为连接线添加高亮样式。

```javascript
function highlightPathToRoot(node) {
    svg.selectAll('.link').classed('highlighted-path', false);
    
    let current = node;
    let path = [];
    while (current.parent) {
        path.push({source: current.parent, target: current});
        current = current.parent;
    }
    
    svg.selectAll('.link')
        .filter(d => path.some(p => 
            p.source === d.source && p.target === d.target
        ))
        .classed('highlighted-path', true);
}
```

- `svg.selectAll('.link').classed('highlighted-path', false);`：首先清除之前的高亮样式。
- `while (current.parent) {...}`：遍历从目标节点到根节点的路径，并将路径存储在数组中。
- `svg.selectAll('.link').filter(...).classed('highlighted-path', true);`：为路径中的连接线添加高亮样式。

#### 7. 平滑过渡函数

平滑过渡到目标节点的位置通过 `scrollToNode` 函数实现。

```javascript
function scrollToNode(node) {
    const nodeY = node.x + margin.top;
    window.scrollTo({
        top: nodeY - window.innerHeight / 2,
        behavior: 'smooth'
    });
}
```

- `const nodeY = node.x + margin.top;`：计算目标节点的 Y 坐标。
- `window.scrollTo({...})`：使用 `scrollTo` 方法平滑滚动到目标节点的位置，设置 `behavior: 'smooth'` 实现平滑过渡效果。

#### 8. 总结

搜索节点并平滑过渡到节点位置的功能通过事件监听、数据过滤、结果显示和点击事件处理实现。用户在输入框中输入关键词时，实时匹配节点并显示结果。点击搜索结果后，突出显示路径并平滑滚动到目标节点的位置。通过这些步骤，用户能够方便地查找和定位树状图中的节点。

## 时间段过滤器.md

### 时间段过滤器实现分析报告

#### 1. HTML 结构

时间段过滤器的 HTML 结构主要由一个下拉选择框和一个按钮组成。下拉框用于选择不同的时间段，按钮用于导航到另一个页面。

```html
<div class="time-filter">
    <div class="filter-title">Tidy Tree</div>
    <select id="era-select">
        <option value="all">全部时期</option>
        <option value="冥古宙">冥古宙</option>
        <option value="太古宙">太古宙</option>
        <option value="元古宙">元古宙</option>
        <option value="显生宙">显生宙</option>
        <option value="中生代">中生代</option>
        <option value="新生代">新生代</option>
        <option value="第四纪">第四纪</option>
    </select>
    <button class="control-button" onclick="window.location.href='./radial-tidy-tree.html'">
        <span>Radial Tidy Tree</span>
        <span class="button-arrow">→</span>
    </button>
</div>
```

#### 2. 事件监听

时间段过滤器的核心功能是通过下拉框的选择来过滤树状图的数据。实现这一功能的关键在于为下拉框添加事件监听器。

```javascript
d3.select("#era-select").on("change", function() {
    const selectedEra = this.value;
    renderTree(treeData, selectedEra);
});
```

- `d3.select("#era-select")`：选择下拉框元素。
- `.on("change", function() {...})`：为下拉框添加 `change` 事件监听器，当用户选择不同的时间段时触发该事件。

#### 3. 获取选定的时间段

在事件处理函数中，通过 `this.value` 获取用户选择的时间段。

```javascript
const selectedEra = this.value;
```

- `this.value`：获取当前下拉框的选定值，可能的值包括“全部时期”或具体的地质时期。

#### 4. 调用渲染函数

获取到选定的时间段后，调用 `renderTree` 函数来重新渲染树状图。

```javascript
renderTree(treeData, selectedEra);
```

- `renderTree(treeData, selectedEra)`：将原始数据 `treeData` 和选定的时间段 `selectedEra` 传递给 `renderTree` 函数，以便根据选择的时间段过滤数据并更新树状图。

#### 5. 数据过滤逻辑

在 `renderTree` 函数内部，首先会清除现有的 SVG 内容，然后根据选定的时间段过滤数据。

```javascript
let filteredData = JSON.parse(JSON.stringify(data));
if (filter !== 'all') {
    filteredData.children = filteredData.children.filter(d => d.name === filter);
}
```

- `JSON.parse(JSON.stringify(data))`：深拷贝原始数据，以避免直接修改原始数据。
- `if (filter !== 'all')`：检查选定的时间段是否为“全部时期”。
- `filteredData.children = filteredData.children.filter(d => d.name === filter)`：如果不是“全部时期”，则过滤出与选定时间段名称匹配的子节点。

#### 6. 渲染更新

经过过滤后，调用 D3.js 的方法重新计算树的布局并更新 SVG 内容，以反映新的数据状态。

```javascript
const root = d3.hierarchy(filteredData);
tree(root);
```

- `d3.hierarchy(filteredData)`：将过滤后的数据转换为层次结构。
- `tree(root)`：计算节点的位置并更新树的布局。

#### 7. 总结

时间段过滤器通过 HTML 下拉框和 D3.js 的事件监听机制实现。用户选择不同的时间段时，触发 `change` 事件，获取选定的值并调用 `renderTree` 函数。该函数根据选定的时间段过滤数据，并重新渲染树状图。通过这种方式，用户可以动态地查看不同时间段的生物演化树。

## 树状图.md

### 树状图节点与边的展示实现分析报告

#### 1. 数据准备

在树状图的实现中，节点和边的展示依赖于 D3.js 提供的层次结构数据。首先，使用 `d3.hierarchy` 方法将数据转换为层次结构，以便 D3 可以处理和渲染。

```javascript
const root = d3.hierarchy(filteredData);
```

#### 2. 计算节点位置

在调用 `tree(root)` 之前，D3 会根据层次结构计算每个节点的位置。`tree` 布局会根据节点的深度和兄弟节点的数量自动计算每个节点的 `x` 和 `y` 坐标。

```javascript
tree(root);
```

#### 3. 绘制边（连接线）

边的绘制是通过连接节点之间的路径来实现的。使用 `root.links()` 获取所有连接的边数据，并通过 D3 的数据绑定机制将这些数据与 SVG 路径元素关联。

```javascript
const links = svg.selectAll(".link")
    .data(root.links())
    .enter()
    .append("path")
    .attr("class", "link")
    .attr("d", d3.linkHorizontal()
        .x(d => d.y)  // 使用节点的 y 坐标
        .y(d => d.x)  // 使用节点的 x 坐标
    );
```

- `svg.selectAll(".link")`：选择所有的连接线元素。
- `.data(root.links())`：将连接线数据绑定到选择的元素。
- `.enter().append("path")`：为每条连接线创建一个新的路径元素。
- `.attr("class", "link")`：为路径元素添加 CSS 类，以便于样式设置。
- `.attr("d", d3.linkHorizontal().x(...).y(...))`：使用 `d3.linkHorizontal()` 创建连接线的路径，`x` 和 `y` 分别对应节点的坐标。

#### 4. 绘制节点

节点的绘制是通过创建 SVG 组元素（`<g>`）来实现的。每个节点的圆圈和文本标签都被添加到这些组元素中。

```javascript
const nodes = svg.selectAll(".node")
    .data(root.descendants())
    .enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.y},${d.x})`);
```

- `svg.selectAll(".node")`：选择所有的节点元素。
- `.data(root.descendants())`：将节点数据绑定到选择的元素。
- `.enter().append("g")`：为每个节点创建一个新的组元素。
- `.attr("class", "node")`：为组元素添加 CSS 类。
- `.attr("transform", d => `translate(${d.y},${d.x})`)`：根据计算出的坐标位置移动组元素。

#### 5. 添加节点的圆圈

在每个节点的组元素中，添加一个圆圈元素来表示节点。

```javascript
nodes.append("circle")
    .attr("r", 5);
```

- `nodes.append("circle")`：在每个节点组中添加一个圆圈。
- `.attr("r", 5)`：设置圆圈的半径为 5。

#### 6. 添加节点的文本标签

在每个节点的组元素中，添加文本标签以显示节点的名称。

```javascript
nodes.append("text")
    .attr("dy", ".35em")
    .attr("x", d => d.children ? -40 : 40)
    .attr("text-anchor", d => d.children ? "end" : "start")
    .text(d => d.data.name);
```

- `nodes.append("text")`：在每个节点组中添加文本元素。
- `.attr("dy", ".35em")`：设置文本的垂直对齐。
- `.attr("x", d => d.children ? -40 : 40)`：根据节点是否有子节点来设置文本的水平位置。
- `.attr("text-anchor", d => d.children ? "end" : "start")`：根据节点是否有子节点来设置文本的对齐方式。
- `.text(d => d.data.name)`：设置文本内容为节点的名称。

#### 7. 总结

节点与边的展示通过 D3.js 的数据绑定和 SVG 元素的创建实现。首先，数据被转换为层次结构，然后计算节点的位置。接着，使用路径元素绘制连接线，并为每个节点创建组元素，添加圆圈和文本标签。通过这些步骤，树状图的节点和边得以清晰地展示。

## 节点的创建与定位.md

### 鼠标悬停节点时定位节点并展示详细信息实现分析报告

#### 1. 节点的创建

在树状图中，每个节点都是通过 D3.js 创建的 SVG 组元素。节点的创建过程包括添加圆圈、文本标签和事件监听器。

```javascript
const nodes = svg.selectAll(".node")
    .data(root.descendants())
    .enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.y},${d.x})`);
```

- `svg.selectAll(".node")`：选择所有节点元素。
- `.data(root.descendants())`：将层次结构中的所有节点数据绑定到选择的元素。
- `.enter().append("g")`：为每个节点创建一个新的组元素。
- `.attr("transform", d => `translate(${d.y},${d.x})`)`：根据计算出的坐标位置移动组元素。

#### 2. 添加鼠标事件监听器

为每个节点添加鼠标悬停事件监听器，以便在用户将鼠标悬停在节点上时触发相应的操作。

```javascript
nodes.on("mouseover", function(event, d) {
    // 显示工具提示
})
.on("mouseout", function(event, d) {
    // 隐藏工具提示
});
```

- `nodes.on("mouseover", function(event, d) {...})`：为节点添加 `mouseover` 事件监听器。
- `on("mouseout", function(event, d) {...})`：为节点添加 `mouseout` 事件监听器。

#### 3. 显示工具提示

在 `mouseover` 事件处理函数中，获取当前节点的数据并显示工具提示。

```javascript
const tooltip = d3.select(".tooltip");

tooltip.style("display", "block")
    .html(`
        <strong>${d.data.name}</strong>
        ${d.data.src ? `<img src="${d.data.src}" alt="${d.data.name}">` : ''}
        <div class="tooltip-text">
            ${d.data.name ? '<br>时间: ' + d.data.name : ''}
            ${d.data.description ? '<br>描述: ' + d.data.description : ''}
        </div>
    `)
    .style("left", tooltipX + "px")
    .style("top", tooltipY + "px");
```

- `const tooltip = d3.select(".tooltip");`：选择工具提示元素。
- `tooltip.style("display", "block")`：将工具提示显示出来。
- `.html(...)`：设置工具提示的内容，包括节点名称、图片和描述信息。
- `.style("left", tooltipX + "px")` 和 `.style("top", tooltipY + "px")`：根据鼠标位置设置工具提示的显示位置。

#### 4. 计算工具提示位置

在 `mouseover` 事件处理函数中，计算工具提示的显示位置，以确保其在视口内可见。

```javascript
const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
const scrollY = window.pageYOffset || document.documentElement.scrollTop;

const viewportWidth = window.innerWidth;
const viewportHeight = window.innerHeight;

let tooltipX;
if (event.clientX > viewportWidth / 2) {
    tooltipX = event.clientX + scrollX - tooltipWidth - 20; // 显示在左侧
} else {
    tooltipX = event.clientX + scrollX + 20; // 显示在右侧
}

let tooltipY = event.clientY + scrollY + 20; // 垂直位置
```

- `const scrollX = window.pageXOffset || document.documentElement.scrollLeft;`：获取当前页面的水平滚动位置。
- `const scrollY = window.pageYOffset || document.documentElement.scrollTop;`：获取当前页面的垂直滚动位置。
- `const viewportWidth = window.innerWidth;` 和 `const viewportHeight = window.innerHeight;`：获取视口的宽度和高度。
- 根据鼠标位置计算工具提示的 X 和 Y 坐标，确保工具提示不会超出视口边界。

#### 5. 隐藏工具提示

在 `mouseout` 事件处理函数中，隐藏工具提示。

```javascript
tooltip.style("display", "none");
```

- `tooltip.style("display", "none");`：将工具提示隐藏。

#### 6. 处理工具提示的鼠标事件

为了确保工具提示在鼠标悬停时保持可见，添加工具提示的鼠标事件处理。

```javascript
tooltip
    .on("mouseover", function() {
        // 清除隐藏的timeout
        if (hideTimeout) {
            clearTimeout(hideTimeout);
        }
        tooltip.style("display", "block");
    })
    .on("mouseout", function(event) {
        // 设置200ms的延迟
        hideTimeout = setTimeout(() => {
            tooltip.style("display", "none");
        }, 200);
    });
```

- `tooltip.on("mouseover", function() {...})`：当鼠标悬停在工具提示上时，清除隐藏的定时器，保持工具提示可见。
- `tooltip.on("mouseout", function(event) {...})`：当鼠标移出工具提示时，设置一个定时器，200毫秒后隐藏工具提示。

#### 7. 总结

鼠标悬停节点时定位节点并展示详细信息的功能通过 D3.js 的事件监听机制实现。为每个节点添加 `mouseover` 和 `mouseout` 事件监听器，在鼠标悬停时获取节点数据并显示工具提示。通过计算工具提示的位置，确保其在视口内可见，并在鼠标移出时隐藏工具提示。通过这些步骤，用户能够直观地查看每个节点的详细信息。

# biological-evolution-tree-3D

## readme.txt

Tree-3D的实现过程与biological-evolution-star-3D星空图基本一样
核心分析请参考biological-evolution-star-3D文件

# biological-evolution-visualization-3D

## 三维力导向图 - 补充.md

### 三维力导向图的实现分析

在该代码中，虽然D3.js的力导向图通常是平面的，但通过结合Three.js的3D渲染能力，代码实现了一个三维的力导向图。以下是实现三维效果的关键步骤和方法：

#### 1. 3D坐标系统的引入
- **节点的三维坐标**:
  - 在`processData`函数中，节点的初始位置是随机生成的三维坐标（x, y, z），这为后续的三维效果奠定了基础。

```javascript
nodes.forEach(node => {
    node.x = Math.random() * 500 - 250; // 随机生成x坐标
    node.y = Math.random() * 500 - 250; // 随机生成y坐标
    node.z = Math.random() * 500 - 250; // 随机生成z坐标
});
```

#### 2. 自定义3D力
- **创建3D力的函数**:
  - 代码中定义了`create3DForce`函数，该函数用于在Z轴方向上施加随机力，从而使节点在三维空间中移动。

```javascript
function create3DForce(strength = 1) {
    return function (alpha) {
        nodes.forEach(node => {
            const zForce = (Math.random() - 0.5) * strength * 20; // 增大Z轴力度
            node.vx += (Math.random() - 0.5) * alpha * strength * 10;
            node.vy += (Math.random() - 0.5) * alpha * strength * 10;
            node.vz += zForce * alpha; // 应用Z轴的力
        });
    };
}
```

#### 3. 更新节点位置
- **在`updatePositions`函数中**:
  - 每次D3的tick事件触发时，更新节点的三维位置。节点的Z坐标会根据施加的力进行更新，从而实现三维效果。

```javascript
function updatePositions() {
    nodes.forEach(node => {
        if (node.object) {
            node.object.position.x += (node.x - node.object.position.x) * 0.1; // 更新X坐标
            node.object.position.y += (node.y - node.object.position.y) * 0.1; // 更新Y坐标
            node.object.position.z += (node.z - node.object.position.z) * 0.1; // 更新Z坐标
        }
    });
}
```

#### 4. 连接线的三维效果
- **连接线的创建**:
  - 在`createGraphObjects`函数中，连接线（边）也被创建为3D对象。通过Three.js的几何体和材质，连接线在三维空间中被渲染。

```javascript
links.forEach(link => {
    link.object = createEdge('line'); // 创建连接线
    scene.add(link.object); // 将连接线添加到场景中
});
```

#### 5. 视角控制
- **OrbitControls的使用**:
  - 通过`THREE.OrbitControls`，用户可以在三维空间中自由旋转、缩放和移动视角，从而更好地观察三维力导向图的结构。

```javascript
controls = new THREE.OrbitControls(camera, renderer.domElement);
```

#### 6. 渲染循环
- **动画循环**:
  - 在`animate`函数中，使用`requestAnimationFrame`持续渲染场景，确保节点和连接线在三维空间中的动态变化被实时更新。

```javascript
function animate() {
    requestAnimationFrame(animate);
    controls.update(); // 更新控制器
    renderer.render(scene, camera); // 渲染场景
}
```

### 总结
通过结合D3.js的力导向布局和Three.js的3D渲染能力，该代码实现了一个动态的三维力导向图。节点在三维空间中随机分布，并通过自定义的3D力进行动态更新，连接线则在三维空间中被渲染。用户可以通过控制视角来观察整个图形的结构和变化。

## 三维力导向图.md

### 三维力导向图实现分析报告（完善版）

#### 1. 概述
该代码实现了一个三维力导向图，使用了Three.js和D3.js库。力导向图通过物理模拟来展示节点及其之间的连接关系，节点的位置会根据力的作用而动态变化。Three.js负责3D图形的渲染和场景的构建，而D3.js则用于数据处理和力导向布局的实现。

#### 2. 主要组件
- **Three.js**: 用于创建和渲染3D场景，处理3D对象的创建、光照、相机控制等。
- **D3.js**: 用于处理数据和实现力导向布局，计算节点之间的物理力。
- **HTML/CSS**: 用于构建用户界面和样式。

#### 3. 代码流程分析

##### 3.1 初始化
- **`init()` 函数**:
  - 创建Three.js场景、相机和渲染器。
  - 设置相机的位置和视角。
  - 添加OrbitControls以允许用户通过鼠标控制视角。
  - 调用`processData(treeData)`处理数据，生成节点和连接。
  - 初始化节点的随机位置。
  - 创建D3力导向模拟。

```javascript
function init() {
    // 初始化场景、相机、渲染器等
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    // 添加控制器
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    // 处理数据
    processData(treeData);
    // 初始化节点位置
    nodes.forEach(node => {
        node.x = Math.random() * 500 - 250;
        node.y = Math.random() * 500 - 250;
        node.z = Math.random() * 500 - 250;
    });
    // 创建D3力导向模拟
    simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100).strength(1))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", createCenter3D(0, 0, 0).strength(0.1))
        .force("collision", d3.forceCollide().radius(20))
        .force("3d", create3DForce(1))
        .force("axis", createAxisForce())
        .on("tick", updatePositions);
}
```

##### 3.2 数据处理
- **`processData(data, parent)` 函数**:
  - 递归处理输入数据，生成节点和连接。
  - 为每个节点分配颜色，基于其在地质年代中的位置。
  - 将节点和连接存储在`nodes`和`links`数组中。

```javascript
function processData(data, parent = null) {
    const node = {
        id: data.name,
        name: data.name,
        time: data.time || "",
        description: data.description || "",
        src: data.src,
        size: 5
    };
    // 颜色分配逻辑
    nodes.push(node);
    if (parent) {
        links.push({
            source: parent.id,
            target: node.id
        });
    }
    // 递归处理子节点
    if (data.children) {
        data.children.forEach(child => {
            child.parent = data;  // 设置父节点引用
            processData(child, node);
        });
    }
}
```

##### 3.3 Three.js的作用
- **3D场景的创建**:
  - 使用`THREE.Scene()`创建一个新的场景，所有的3D对象（节点、连接线、光源等）都将添加到这个场景中。

- **相机的设置**:
  - 使用`THREE.PerspectiveCamera`创建一个透视相机，设置视角、宽高比、近远裁剪面等参数，以便于在3D空间中观察场景。

- **渲染器的初始化**:
  - 使用`THREE.WebGLRenderer`创建一个WebGL渲染器，负责将场景渲染到HTML元素中。
  - 设置渲染器的大小和抗锯齿效果。

- **节点和连接的创建**:
  - 在`createGraphObjects()`函数中，使用Three.js的几何体和材质创建节点（球体）和连接（线条）。
  - 节点的颜色和大小根据数据动态设置。

```javascript
function createGraphObjects() {
    nodes.forEach(node => {
        const geometry = new THREE.SphereGeometry(node.size);
        const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color(node.color || 0x00ff00) // 默认颜色
        });
        const sphere = new THREE.Mesh(geometry, material);
        node.object = sphere;
        scene.add(sphere);
    });

    links.forEach(link => {
        link.object = createEdge('line'); // 默认使用直线
        scene.add(link.object);
    });

    // 添加光源使3D效果更明显
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(100, 100, 100);
    scene.add(pointLight);
}
```

- **更新位置**:
  - 在`updatePositions()`函数中，使用Three.js更新每个节点和连接的3D位置，确保它们在每次模拟的tick事件中平滑过渡。

```javascript
function updatePositions() {
    nodes.forEach(node => {
        if (node.object) {
            node.object.position.x += (node.x - node.object.position.x) * 0.1;
            node.object.position.y += (node.y - node.object.position.y) * 0.1;
            node.object.position.z += (node.z - node.object.position.z) * 0.1;
        }
    });

    links.forEach(link => {
        // 更新连接线的几何体
    });
}
```

- **渲染循环**:
  - 在`animate()`函数中，使用`requestAnimationFrame`创建一个渲染循环，持续更新场景和相机视角，确保场景实时渲染。

```javascript
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}
```

##### 3.4 D3.js的作用
- **力导向模拟**:
  - 使用`d3.forceSimulation`创建模拟，定义了多个力（链接力、斥力、中心力、碰撞力、3D力和轴向力）。
  - 每个力的参数可以通过用户界面进行调整。

```javascript
simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(100).strength(1))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", createCenter3D(0, 0, 0).strength(0.1))
    .force("collision", d3.forceCollide().radius(20))
    .force("3d", create3DForce(1))
    .force("axis", createAxisForce())
    .on("tick", updatePositions);
```

##### 3.5 用户交互
- 通过HTML元素（如滑块和按钮）允许用户调整力的强度、节点大小、背景颜色等。
- 事件监听器用于响应用户输入，更新模拟参数并重启模拟。

```javascript
document.getElementById('gravity').addEventListener('input', (e) => {
    const strength = (e.target.value - 50) / 50; // 将范围转换为 -1 到 1
    simulation.force("center", createCenter3D(0, 0, 0).strength(Math.abs(strength)));
    simulation.alpha(1).restart(); // 重启模拟
});
```

#### 4. 总结
该三维力导向图通过Three.js和D3.js的结合，实现了动态的节点和连接展示。Three.js负责3D图形的渲染和场景的构建，而D3.js则用于数据处理和力导向布局的实现。用户可以通过界面交互调整图的参数，实时观察变化。代码结构清晰，功能模块化，便于维护和扩展。

## 天空盒.md

### 天空盒实现分析报告

天空盒的实现主要依赖于Three.js库中的`THREE.CubeTextureLoader`类。以下是具体的代码流程分析：

#### 1. 选择天空盒

在HTML中，有一个下拉选择框用于选择不同的天空盒：

```html
<select id="cubeSelect">
    <option value="none" selected>无</option>
    <option value="taikong">太空</option>
    <option value="outer_space">外太空</option>
    ...
</select>
```

用户可以通过这个选择框选择不同的天空盒类型。

#### 2. 事件监听

当用户选择天空盒时，会触发`change`事件，相关代码如下：

```javascript
document.getElementById('cubeSelect').addEventListener('change', (e) => {
    const selectedSkybox = e.target.value;
    // 当选择立方体天空盒时，重置全景天空盒选择
    if (selectedSkybox !== 'none') {
        document.getElementById('panoramaSelect').value = 'none';
    }
    ...
});
```

这段代码首先检查用户选择的天空盒是否为“无”，如果不是，则重置全景天空盒的选择。

#### 3. 加载天空盒纹理

如果用户选择了一个有效的天空盒，代码会根据选择的值加载相应的纹理：

```javascript
const loader = new THREE.CubeTextureLoader();
let urls;

switch (selectedSkybox) {
    case 'taikong':
        urls = [
            './static-other/Skybox_Texture/立方体天空盒/taikong/right.jpg',
            './static-other/Skybox_Texture/立方体天空盒/taikong/left.jpg',
            ...
        ];
        break;
    ...
}

if (urls) {
    showLoadingMessage(true, '立方体');
    loader.load(
        urls,
        (skyboxTexture) => {
            scene.background = skyboxTexture;
            showLoadingMessage(false);
        },
        undefined,
        (error) => {
            console.error('天空盒加载失败:', error);
            showLoadingMessage(false);
        }
    );
}
```

- **纹理路径**：根据用户选择的天空盒，构建一个包含六个面纹理路径的数组（`urls`）。
- **加载器**：使用`THREE.CubeTextureLoader`实例化一个加载器。
- **加载纹理**：调用`loader.load`方法，传入纹理路径数组。该方法接受三个参数：
  - **成功回调**：当纹理加载成功时，将加载的纹理设置为场景的背景。
  - **进度回调**：此处未使用，但可以用于显示加载进度。
  - **错误回调**：如果加载失败，输出错误信息。

#### 4. 更新场景背景

在成功回调中，设置场景的背景为加载的天空盒纹理：

```javascript
scene.background = skyboxTexture;
```

这行代码将天空盒纹理应用到Three.js的场景中，使得场景的背景呈现为立方体天空盒的效果。

#### 5. 处理加载提示

在加载开始时，调用`showLoadingMessage(true, '立方体')`显示加载提示，加载完成后调用`showLoadingMessage(false)`隐藏提示。这提供了用户友好的反馈，告知用户正在加载天空盒。

#### 6. 处理错误

如果天空盒加载失败，错误回调会输出错误信息，并隐藏加载提示：

```javascript
console.error('天空盒加载失败:', error);
showLoadingMessage(false);
```

### 总结

天空盒的实现流程主要包括用户选择天空盒、加载相应的纹理、设置场景背景以及处理加载状态和错误。通过使用Three.js的`CubeTextureLoader`，可以方便地实现立方体天空盒的效果，为3D场景提供丰富的背景视觉体验。

# home-page

## 选项卡.md

### 代码流程分析报告

该代码实现了一个旋转卡片展示效果，主要通过HTML、CSS和JavaScript的结合来完成。以下是对代码流程的详细分析：

#### 1. HTML结构

- **文档类型和语言设置**：
  ```html
  <!DOCTYPE html>
  <html lang="zh">
  ```
  这部分定义了文档类型为HTML5，并设置语言为中文。

- **头部信息**：
  ```html
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>旋转卡片展示</title>
      <link rel="icon" href="./static-other/icon/favicon.ico" type="image/x-icon">
      <style>
          /* CSS样式 */
      </style>
  </head>
  ```
  这里设置了字符编码、视口设置和页面标题，并引入了图标和CSS样式。

- **主体内容**：
  ```html
  <body>
      <div>
          <span class="title">点击卡片进入页面</span>
          <a class="title-left" href="./4-screen-home-page.html">使用四象限组合页面→</a>
      </div>
      <div class="container">
          <script>
              // JavaScript代码
          </script>
      </div>
  </body>
  ```
  主体部分包含一个标题和一个链接，接着是一个容器用于放置卡片。

#### 2. CSS样式

- **整体布局**：
  ```css
  body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
      perspective: 1000px;
  }
  ```
  使用Flexbox布局使内容居中，并设置背景为渐变色，增加了透视效果。

- **卡片样式**：
  ```css
  .card-wrapper {
      position: relative;
      width: 400px;
      height: 400px;
      transition: transform 0.3s ease;
  }
  ```
  每个卡片的外部容器设置了相对定位和尺寸，并添加了平滑的变换效果。

- **卡片的前后面**：
  ```css
  .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 15px;
      overflow: hidden;
  }
  .card-back {
      display: none;
  }
  ```
  卡片的前后面使用绝对定位，确保它们重叠在一起。卡片背面初始状态为隐藏。

#### 3. JavaScript逻辑

- **动态生成卡片**：
  ```javascript
  const images = [
      'biological-classification-sunburst-2D',
      'biological-evolution-force-2D',
      // 其他图像
  ];
  
  images.forEach(img => {
      document.write(`
          <div class="card-wrapper">
              <a href="./${img}.html">
                  <div class="card">
                      <div class="card-face card-front">
                          <img src="./select-cards/${img}.png" alt="${img}">
                      </div>
                      <div class="card-face card-back">
                          <span>点击查看详情</span>
                      </div>
                  </div>
              </a>
          </div>
      `);
  });
  ```
  使用`document.write`动态生成每个卡片的HTML结构，包含前面和背面的内容。

- **鼠标移动效果**：
  ```javascript
  document.querySelectorAll('.card-wrapper').forEach(card => {
      card.addEventListener('mousemove', (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
  
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
  
          const rotateX = (y - centerY) / 10;
          const rotateY = -(x - centerX) / 10;
  
          card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      });
  
      card.addEventListener('mouseleave', () => {
          card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0)';
      });
  });
  ```
  为每个卡片添加了鼠标移动事件，计算鼠标相对于卡片的位置，并根据位置调整卡片的旋转角度，创建3D效果。当鼠标离开时，卡片恢复到初始状态。

### 总结

该代码通过HTML结构、CSS样式和JavaScript逻辑的结合，实现了一个动态的旋转卡片展示效果。用户可以通过鼠标移动与卡片互动，获得生动的视觉体验。

# index

## 设备检测.md

这个页面通过 JavaScript 进行设备检测，以确定用户是使用 PC 端还是移动端。以下是具体的实现步骤和代码分析：

1. **设备检测逻辑**：
   - 页面加载时，`window.onload` 事件会被触发，执行设备检测的代码。
   - 使用正则表达式 `/Mobi|Android/i` 来检测用户的 `userAgent` 字符串。如果匹配到 "Mobi" 或 "Android"，则认为用户使用的是移动设备。
   - 同时，使用 `! /Windows NT/i` 来排除 Windows 设备，以确保只检测移动设备。

2. **根据设备类型的处理**：
   - 如果检测到移动设备，页面会将标题字体缩小，并立即跳转到 `./mobile-index.html`。
   - 如果检测到 PC 端，则直接跳转到 `./pc-index.html`。

3. **代码片段**：
   ```javascript
   window.onload = function() {
       // 显示手动选择按钮
       document.getElementById('manual-selection').style.display = 'block';
   
       // 检测设备类型
       let target = '';
       if (/Mobi|Android/i.test(navigator.userAgent) && !/Windows NT/i.test(navigator.userAgent)) {
           target = '<span class="highlight">移动端</span>';
           // 缩小标题字体
           document.querySelector('.title').style.fontSize = '30px';
           // 立即跳转
           window.location.href = './mobile-index.html';
       } else {
           target = '<span class="highlight">PC端</span>';
           // 立即跳转
           window.location.href = './pc-index.html';
       }
   }
   ```

### 总结
该页面通过 `userAgent` 字符串的检测来判断设备类型，并根据判断结果进行相应的页面跳转。这种方法简单有效，但需要注意的是，`userAgent` 字符串可以被伪造，因此在某些情况下可能不够可靠。

# index-earth

## 地球模型与纹理贴图.md

### 地球模型与纹理贴图实现分析报告

#### 1. 引入必要的库
在HTML文件中，通过以下脚本引入了Three.js库和OrbitControls控制器：
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
```
这两个库提供了创建3D场景和控制相机的功能。

#### 2. 初始化场景
在`init`函数中，创建了一个Three.js场景、相机和渲染器：
```javascript
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ 
        antialias: false, // 关闭抗锯齿以提高性能
        powerPreference: "high-performance" 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}
```
- `THREE.Scene()`：创建一个新的场景。
- `THREE.PerspectiveCamera()`：设置相机的视角和比例。
- `THREE.WebGLRenderer()`：创建一个WebGL渲染器并将其添加到DOM中。

#### 3. 创建地球模型
地球模型的创建主要在以下代码段中完成：
```javascript
const geometry = new THREE.SphereGeometry(5, 32, 32);
const textureLoader = new THREE.TextureLoader();
const textures = {};
const timePoints = [0, 20, 35, 50, 66, 90, 105, 120, 170, 200, 220, 240, 260, 280, 300, 340, 370, 400, 430, 450, 470, 540, 600, 750];
let currentTimeIndex = 0;
let loadedTextures = 0;
const totalTextures = timePoints.length;

timePoints.forEach(time => {
    const fileName = time === 0 ? '0.jpg' : `${time}.jpg`;
    textureLoader.load(
        `./static-other/World_Texture/${fileName}`,
        function (texture) {
            textures[time] = texture;
            loadedTextures++;
            if (time === 0) {
                const material = new THREE.MeshPhongMaterial({
                    map: texture,
                    specular: new THREE.Color('grey'),
                    shininess: 10
                });
                earth = new THREE.Mesh(geometry, material);
                scene.add(earth);
            }
            if (loadedTextures === totalTextures) {
                document.getElementById('loadingText').style.display = 'none';
            }
        },
        undefined,
        function (error) {
            console.error('纹理加载失败:', error);
            loadedTextures++;
            if (loadedTextures === totalTextures) {
                document.getElementById('loadingText').style.display = 'none';
            }
        }
    );
});
```
- `THREE.SphereGeometry(5, 32, 32)`：创建一个半径为5的球体几何体，细分为32个宽度和高度。
- `THREE.TextureLoader()`：创建一个纹理加载器，用于加载地球的纹理。
- `timePoints`数组：定义了不同时间点的纹理文件名。
- `textureLoader.load()`：异步加载纹理，加载完成后创建地球模型并将其添加到场景中。

#### 4. 纹理加载与应用
在纹理加载的回调函数中，首先将加载的纹理存储在`textures`对象中。如果加载的是现代地球的纹理（`time === 0`），则创建地球的材质并将其应用于地球模型：
```javascript
const material = new THREE.MeshPhongMaterial({
    map: texture,
    specular: new THREE.Color('grey'),
    shininess: 10
});
earth = new THREE.Mesh(geometry, material);
scene.add(earth);
```
- `THREE.MeshPhongMaterial`：创建一个具有光泽效果的材质，使用加载的纹理作为贴图。

#### 5. 切换时期的功能
通过`switchToTimeIndex`函数实现了根据用户选择切换不同时间点的地球纹理：
```javascript
function switchToTimeIndex(index) {
    if (index >= 0 && index < timePoints.length) {
        currentTimeIndex = index;
        const time = timePoints[index];
        if (earth && textures[time]) {
            earth.material.map = textures[time];
            earth.material.needsUpdate = true;
            document.getElementById('timeSelect').value = time;
        }
    }
}
```
- 该函数根据传入的索引更新当前时间索引，并将对应的纹理应用到地球模型上。

#### 6. 事件监听
通过事件监听器，用户可以通过选择框或按钮切换不同的时间点：
```javascript
document.getElementById('timeSelect').addEventListener('change', function () {
    const time = parseInt(this.value);
    currentTimeIndex = timePoints.indexOf(time);
    if (earth && textures[time]) {
        earth.material.map = textures[time];
        earth.material.needsUpdate = true;
    }
});
```
- 选择框的变化会触发纹理的切换。

#### 7. 动画与渲染
最后，通过`animate`函数实现了场景的持续渲染：
```javascript
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    if (clouds) {
        clouds.rotation.y += 0.0003;
    }
    renderer.render(scene, camera);
}
```
- `requestAnimationFrame`：创建一个动画循环，持续更新场景和渲染。

### 总结
该代码通过Three.js库实现了一个动态的地球模型，支持不同时间点的纹理切换。通过纹理加载器异步加载地球的纹理，并通过事件监听器实现用户交互，最终在3D场景中渲染出地球模型。

# paleo-geography-3D

## 地球模型与纹理贴图.md

### 地球模型与纹理贴图实现分析报告

#### 1. 引入必要的库
在HTML文件中，通过以下脚本引入了Three.js库和OrbitControls控制器：
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
```
这两个库提供了创建3D场景和控制相机的功能。

#### 2. 初始化场景
在`init`函数中，创建了一个Three.js场景、相机和渲染器：
```javascript
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ 
        antialias: false, // 关闭抗锯齿以提高性能
        powerPreference: "high-performance" 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}
```
- `THREE.Scene()`：创建一个新的场景。
- `THREE.PerspectiveCamera()`：设置相机的视角和比例。
- `THREE.WebGLRenderer()`：创建一个WebGL渲染器并将其添加到DOM中。

#### 3. 创建地球模型
地球模型的创建主要在以下代码段中完成：
```javascript
const geometry = new THREE.SphereGeometry(5, 32, 32);
const textureLoader = new THREE.TextureLoader();
const textures = {};
const timePoints = [0, 20, 35, 50, 66, 90, 105, 120, 170, 200, 220, 240, 260, 280, 300, 340, 370, 400, 430, 450, 470, 540, 600, 750];
let currentTimeIndex = 0;
let loadedTextures = 0;
const totalTextures = timePoints.length;

timePoints.forEach(time => {
    const fileName = time === 0 ? '0.jpg' : `${time}.jpg`;
    textureLoader.load(
        `./static-other/World_Texture/${fileName}`,
        function (texture) {
            textures[time] = texture;
            loadedTextures++;
            if (time === 0) {
                const material = new THREE.MeshPhongMaterial({
                    map: texture,
                    specular: new THREE.Color('grey'),
                    shininess: 10
                });
                earth = new THREE.Mesh(geometry, material);
                scene.add(earth);
            }
            if (loadedTextures === totalTextures) {
                document.getElementById('loadingText').style.display = 'none';
            }
        },
        undefined,
        function (error) {
            console.error('纹理加载失败:', error);
            loadedTextures++;
            if (loadedTextures === totalTextures) {
                document.getElementById('loadingText').style.display = 'none';
            }
        }
    );
});
```
- `THREE.SphereGeometry(5, 32, 32)`：创建一个半径为5的球体几何体，细分为32个宽度和高度。
- `THREE.TextureLoader()`：创建一个纹理加载器，用于加载地球的纹理。
- `timePoints`数组：定义了不同时间点的纹理文件名。
- `textureLoader.load()`：异步加载纹理，加载完成后创建地球模型并将其添加到场景中。

#### 4. 纹理加载与应用
在纹理加载的回调函数中，首先将加载的纹理存储在`textures`对象中。如果加载的是现代地球的纹理（`time === 0`），则创建地球的材质并将其应用于地球模型：
```javascript
const material = new THREE.MeshPhongMaterial({
    map: texture,
    specular: new THREE.Color('grey'),
    shininess: 10
});
earth = new THREE.Mesh(geometry, material);
scene.add(earth);
```
- `THREE.MeshPhongMaterial`：创建一个具有光泽效果的材质，使用加载的纹理作为贴图。

#### 5. 切换时期的功能
通过`switchToTimeIndex`函数实现了根据用户选择切换不同时间点的地球纹理：
```javascript
function switchToTimeIndex(index) {
    if (index >= 0 && index < timePoints.length) {
        currentTimeIndex = index;
        const time = timePoints[index];
        if (earth && textures[time]) {
            earth.material.map = textures[time];
            earth.material.needsUpdate = true;
            document.getElementById('timeSelect').value = time;
        }
    }
}
```
- 该函数根据传入的索引更新当前时间索引，并将对应的纹理应用到地球模型上。

#### 6. 事件监听
通过事件监听器，用户可以通过选择框或按钮切换不同的时间点：
```javascript
document.getElementById('timeSelect').addEventListener('change', function () {
    const time = parseInt(this.value);
    currentTimeIndex = timePoints.indexOf(time);
    if (earth && textures[time]) {
        earth.material.map = textures[time];
        earth.material.needsUpdate = true;
    }
});
```
- 选择框的变化会触发纹理的切换。

#### 7. 动画与渲染
最后，通过`animate`函数实现了场景的持续渲染：
```javascript
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    if (clouds) {
        clouds.rotation.y += 0.0003;
    }
    renderer.render(scene, camera);
}
```
- `requestAnimationFrame`：创建一个动画循环，持续更新场景和渲染。

### 总结
该代码通过Three.js库实现了一个动态的地球模型，支持不同时间点的纹理切换。通过纹理加载器异步加载地球的纹理，并通过事件监听器实现用户交互，最终在3D场景中渲染出地球模型。

# pc-index

## 旋转立方体.md

### 报告：旋转立方体的实现分析

在该 HTML 文件中，旋转立方体的实现主要依赖于 Three.js 库。以下是实现流程的详细分析：

#### 1. 引入 Three.js 库
在 `<script>` 标签中引入了 Three.js 库：
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
```
这使得后续的 3D 场景和对象的创建成为可能。

#### 2. 创建场景、相机和渲染器
在 JavaScript 代码中，首先创建了一个 Three.js 场景、相机和渲染器：
```javascript
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
```
- **场景**：用于容纳所有的 3D 对象。
- **相机**：用于观察场景，设置视角。
- **渲染器**：负责将场景渲染到屏幕上。

#### 3. 创建几何体和材质
接下来，创建了一个旋转的立方体（在代码中是一个 icosahedron，类似于立方体）：
```javascript
const geometry = new THREE.IcosahedronGeometry(1, 0);
const material = new THREE.MeshPhongMaterial({
    color: 0x00ff00,
    wireframe: true
});
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);
```
- **几何体**：使用 `IcosahedronGeometry` 创建一个 icosahedron 形状。
- **材质**：使用 `MeshPhongMaterial` 设置颜色和线框模式。
- **网格**：将几何体和材质结合成一个网格，并添加到场景中。

#### 4. 添加光源
为了使立方体可见，添加了一个光源：
```javascript
const light = new THREE.PointLight(0xffffff, 1, 100);
light.position.set(10, 10, 10);
scene.add(light);
```
- **光源**：使用 `PointLight` 创建一个点光源，设置其位置并添加到场景中。

#### 5. 动画循环
通过 `requestAnimationFrame` 创建一个动画循环，使立方体不断旋转：
```javascript
function animate() {
    requestAnimationFrame(animate);
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
    renderer.render(scene, camera);
}
animate();
```
- **动画函数**：在每一帧中，增加立方体的 `x` 和 `y` 轴的旋转角度。
- **渲染**：每次更新后，调用 `renderer.render` 方法将场景渲染到屏幕上。

#### 6. 窗口大小变化响应
最后，添加了窗口大小变化的响应，以确保在调整窗口大小时，场景能够正确显示：
```javascript
window.addEventListener('resize', onWindowResize, false);
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
```
- **事件监听**：监听窗口的 `resize` 事件，更新相机的宽高比和渲染器的大小。

### 总结
通过以上步骤，代码实现了一个旋转的立方体。主要流程包括创建场景、相机、渲染器，定义几何体和材质，添加光源，设置动画循环，以及处理窗口大小变化。通过 Three.js 的强大功能，开发者能够轻松地创建和控制 3D 对象。

# radial-tidy-tree

## 搜索.md

### 搜索功能实现分析报告

#### 1. DOM 元素选择
首先，通过 `document.querySelector` 选择搜索输入框和搜索结果面板。这些元素将用于捕获用户输入和显示搜索结果。

```javascript
const searchInput = document.querySelector('.search-input');
const searchResult = document.querySelector('.search-result');
```

#### 2. 搜索函数定义
定义 `searchNodes` 函数，该函数接收用户输入的查询字符串 `query`。该函数的主要任务是遍历树形数据中的所有节点，并根据用户的输入过滤出匹配的节点。

```javascript
function searchNodes(query) {
    const results = [];
    root.descendants().forEach(node => {
        const name = node.data.name || '';
        const description = node.data.description || '';
        const time = node.data.time || '';
        
        // 如果没有查询词，显示所有节点
        if (!query || name.toLowerCase().includes(query.toLowerCase()) ||
            description.toLowerCase().includes(query.toLowerCase()) ||
            time.toLowerCase().includes(query.toLowerCase())) {
            results.push(node);
        }
    });

    displaySearchResults(results);
    searchResult.style.display = 'block'; // 始终显示搜索结果面板
}
```

- **节点遍历**：使用 `root.descendants()` 遍历所有节点。
- **条件判断**：检查节点的名称、描述和时间是否包含查询字符串。如果查询为空，则将所有节点添加到结果中。
- **结果存储**：将匹配的节点存储在 `results` 数组中，并调用 `displaySearchResults` 函数显示结果。

#### 3. 显示搜索结果
定义 `displaySearchResults` 函数，该函数负责将搜索结果渲染到页面上。

```javascript
function displaySearchResults(results) {
    searchResult.innerHTML = '';
    
    if (results.length === 0) {
        searchResult.innerHTML = '<div class="search-result-item">未找到相关结果</div>';
        searchResult.style.display = 'block';
        return;
    }

    results.forEach(node => {
        const div = document.createElement('div');
        div.className = 'search-result-item';
        div.textContent = `${node.data.name} ${node.data.time || ''}`;
        div.addEventListener('click', (event) => {
            event.stopPropagation(); // 阻止事件冒泡
            highlightPath(node);
        });
        searchResult.appendChild(div);
    });

    searchResult.style.display = 'block';
}
```

- **清空结果面板**：首先清空 `searchResult` 的内容。
- **无结果处理**：如果没有匹配的节点，显示“未找到相关结果”。
- **结果渲染**：遍历匹配的节点，创建一个新的 `div` 元素，显示节点的名称和时间，并添加点击事件监听器以高亮显示路径。

#### 4. 事件监听
为搜索输入框添加 `input` 事件监听器，以便在用户输入时实时搜索。

```javascript
searchInput.addEventListener('input', (e) => {
    const searchValue = e.target.value;
    searchNodes(searchValue);
    // 保存搜索值到 localStorage (可选)
    localStorage.setItem('lastSearch', searchValue);
});
```

- **实时搜索**：每当用户输入时，调用 `searchNodes` 函数进行搜索。
- **本地存储**：将当前搜索值保存到 `localStorage`，以便在页面加载时恢复。

#### 5. 页面加载时恢复搜索内容
在页面加载时，检查 `localStorage` 中是否有上次搜索的内容，并自动填充搜索框。

```javascript
window.addEventListener('load', () => {
    const lastSearch = localStorage.getItem('lastSearch');
    if (lastSearch) {
        searchInput.value = lastSearch;
        searchNodes(lastSearch);
    }
});
```

- **恢复搜索**：如果存在上次搜索的内容，则将其填入搜索框并调用 `searchNodes` 进行搜索。

#### 6. 聚焦事件监听
为搜索输入框添加 `focus` 事件监听器，以便在获得焦点时显示当前输入值的搜索结果。

```javascript
searchInput.addEventListener('focus', (e) => {
    searchNodes(e.target.value); // 当获得焦点时，显示当前输入值的搜索结果
});
```

#### 7. 点击其他地方关闭搜索结果
添加全局点击事件监听器，当用户点击搜索结果以外的地方时，隐藏搜索结果面板。

```javascript
document.addEventListener('click', (e) => {
    if (!searchResult.contains(e.target) && e.target !== searchInput) {
        searchResult.style.display = 'none';
    }
});
```

### 总结
搜索功能通过实时监听用户输入，遍历树形数据并匹配节点，最终将结果渲染到页面上。通过事件监听和本地存储，增强了用户体验，使得搜索功能更加灵活和便捷。

## 放射状树形图.md

### 放射状树形图节点与边的实现分析报告

#### 1. 数据准备
在代码中，首先通过 `d3.hierarchy(treeData)` 创建一个层级结构的根节点 `root`，其中 `treeData` 是包含树形数据的对象。接着，为每个节点分配一个唯一的 ID，以便后续操作。

```javascript
let nodeId = 0;
const root = d3.hierarchy(treeData);
root.descendants().forEach(d => {
    d.id = nodeId++;
});
```

#### 2. 创建放射状树形图布局
使用 `d3.tree()` 创建树形布局，并设置其大小和节点之间的分离度。这里的 `size` 方法定义了树形图的半径，`separation` 方法定义了同一父节点下的子节点之间的距离。

```javascript
const radius = Math.min(width, height) / 1;
const tree = d3.tree()
    .size([2 * Math.PI, radius])
    .separation((a, b) => {
        return (a.parent == b.parent ? 2 : 3) / a.depth;
    });
```

#### 3. 应用树形布局
通过调用 `tree(root)`，将层级数据转换为放射状树形图的布局数据 `treeData2`。这一步骤计算出每个节点的角度和半径。

```javascript
const treeData2 = tree(root);
```

#### 4. 绘制连接线
使用 `g.selectAll(".link")` 选择所有连接线，并通过 `d3.linkRadial()` 创建连接线的路径。连接线的 `d` 属性由每对父子节点的角度和半径决定。

```javascript
g.selectAll(".link")
    .data(treeData2.links())
    .join("path")
    .attr("class", "link")
    .attr("d", d3.linkRadial()
        .angle(d => d.x)
        .radius(d => d.y));
```

#### 5. 创建节点组
节点组通过 `g.selectAll(".node")` 选择所有节点，并为每个节点创建一个 `g` 元素。每个节点的 `transform` 属性使用 `d3.pointRadial(d.x, d.y)` 计算出节点在放射状图中的位置。

```javascript
const node = g.selectAll(".node")
    .data(treeData2.descendants())
    .join("g")
    .attr("class", "node")
    .attr("transform", d => `
        translate(${d3.pointRadial(d.x, d.y)})
    `);
```

#### 6. 添加节点图标和圆圈
在每个节点组中，首先添加图标（如果有的话），然后添加一个圆圈表示节点。图标的旋转角度通过节点的角度计算得出。

```javascript
node.append("image")
    .attr("xlink:href", d => d.data.src || '')
    .attr("x", 8)
    .attr("y", -12)
    .attr("width", 24)
    .attr("height", 24)
    .attr("transform", d => {
        const angle = (d.x * 180 / Math.PI - 90);
        return `rotate(${angle})`;
    });

node.append("circle")
    .attr("r", 4);
```

#### 7. 添加文本标签
在节点组中添加文本标签，文本的旋转角度与节点的角度一致。文本内容为节点的名称。

```javascript
node.append("text")
    .attr("dy", "0.31em")
    .attr("x", 40)
    .attr("text-anchor", "start")
    .attr("transform", d => {
        const angle = (d.x * 180 / Math.PI - 90);
        return `rotate(${angle})`;
    })
    .text(d => d.data.name);
```

#### 8. 交互功能
节点和连接线的交互功能通过鼠标事件实现，例如显示工具提示和高亮路径。通过 `on("mouseover", showTooltip)` 和 `on("mouseout", hideTooltip)` 为节点和连接线添加事件监听器。

```javascript
node.on("mouseover", showTooltip)
    .on("mouseout", hideTooltip);
```

### 总结
放射状树形图的实现主要依赖于 D3.js 的层级数据处理和 SVG 图形绘制。通过创建树形布局、绘制连接线和节点，并添加交互功能，最终形成一个动态可视化的放射状树形图。

## 旋转树形图.md

### Q 与 E 键旋转图形功能实现分析报告

#### 1. 变量定义
在代码的开始部分，定义了两个变量 `currentRotation` 和 `rotationStep`，用于跟踪当前的旋转角度和每次旋转的步长。

```javascript
let currentRotation = 0;
const rotationStep = 5; // 每次旋转5度
```

- `currentRotation`：初始化为 0，表示图形的初始旋转角度。
- `rotationStep`：设置为 5，表示每次按键旋转的角度。

#### 2. 事件监听
为文档添加 `keydown` 事件监听器，以捕获用户按下的键。

```javascript
document.addEventListener('keydown', (event) => {
    if (event.key === 'q') {
        // 逆时针旋转
        currentRotation -= rotationStep;
        g.attr("transform", `${d3.zoomTransform(svg.node())} rotate(${currentRotation})`);
    } else if (event.key === 'e') {
        // 顺时针旋转
        currentRotation += rotationStep;
        g.attr("transform", `${d3.zoomTransform(svg.node())} rotate(${currentRotation})`);
    }
});
```

- **事件处理**：当用户按下键盘时，触发 `keydown` 事件。
- **按键判断**：
  - 如果按下的是 `q` 键，执行逆时针旋转：
    - 将 `currentRotation` 减去 `rotationStep`，更新当前旋转角度。
    - 使用 `g.attr("transform", ...)` 更新图形的变换属性，应用当前的缩放和旋转。
  - 如果按下的是 `e` 键，执行顺时针旋转：
    - 将 `currentRotation` 加上 `rotationStep`，更新当前旋转角度。
    - 同样使用 `g.attr("transform", ...)` 更新图形的变换属性。

#### 3. 变换属性更新
在更新变换属性时，使用 `d3.zoomTransform(svg.node())` 获取当前的缩放变换，并将其与新的旋转角度结合。

```javascript
g.attr("transform", `${d3.zoomTransform(svg.node())} rotate(${currentRotation})`);
```

- **缩放变换**：`d3.zoomTransform(svg.node())` 返回当前的缩放变换对象，包含平移和缩放信息。
- **旋转变换**：`rotate(${currentRotation})` 将当前的旋转角度应用到图形上。
- **组合变换**：通过字符串模板将缩放和旋转变换组合在一起，形成最终的变换属性。

#### 4. 整体效果
通过上述步骤，用户按下 `q` 或 `e` 键时，图形会根据当前的旋转角度进行相应的旋转。每次按键都会更新 `currentRotation`，并重新应用变换属性，从而实现动态旋转效果。

### 总结
Q 与 E 键的旋转功能通过事件监听、角度更新和变换属性的应用实现。用户的按键输入直接影响图形的旋转状态，使得图形能够在用户交互中动态变化。

## 时间线筛选.md

### 时间线筛选功能实现分析报告

#### 1. HTML 元素定义
在 HTML 中，定义了一个范围输入元素（滑块）和一个用于显示当前选择时间的文本元素。

```html
<div class="bottom-time-filter">
    <input type="range" id="timeSlider" min="0" max="500000" value="500000">
    <span id="timeDisplay">显示所有时期</span>
</div>
```

- **`timeSlider`**：范围输入元素，允许用户选择一个时间值，范围从 0 到 500000（表示 50 亿年）。
- **`timeDisplay`**：用于显示当前选择的时间范围的文本。

#### 2. 初始化设置
在 JavaScript 中，首先设置滑块的初始值和范围，并定义一个函数 `updateView` 用于更新可见节点。

```javascript
// 修改初始化显示
updateView(500000); // 初始显示所有节点 (50亿年)

// 修改滑块初始值
const timeSlider = document.getElementById('timeSlider');
timeSlider.min = 0;     // 最小值为0
timeSlider.max = 500000; // 最大值为50亿年（转换为万年单位）
timeSlider.value = 500000; // 设置初始值为最大值
timeSlider.step = 1;    // 步长为1万年

const timeDisplay = document.getElementById('timeDisplay');
timeDisplay.textContent = "显示所有时期"; // 设置初始显示文本
```

- **`updateView(500000)`**：调用该函数以显示所有节点，初始值为 500000。
- **滑块设置**：设置滑块的最小值、最大值、初始值和步长。

#### 3. 滑块事件监听
为滑块添加 `input` 事件监听器，以便在用户调整滑块时实时更新显示的时间范围和可见节点。

```javascript
timeSlider.addEventListener('input', (event) => {
    const value = parseInt(event.target.value);
    let displayText;
    
    if (value === 500000) {
        displayText = "显示所有时期";
    } else if (value >= 10000) {
        // 大于1亿年的显示
        displayText = `显示距今 ${(value/10000).toFixed(1)} 亿年前及更近时期`;
    } else if (value >= 100) {
        // 大于100万年的显示
        displayText = `显示距今 ${(value/100).toFixed(1)} 百万年前及更近时期`;
    } else {
        // 小于100万年的显示
        displayText = `显示距今 ${value} 万年前及更近时期`;
    }
    
    timeDisplay.textContent = displayText;
    updateView(value);
});
```

- **获取滑块值**：通过 `event.target.value` 获取当前滑块的值，并将其转换为整数。
- **更新显示文本**：根据滑块的值，更新 `timeDisplay` 的文本内容，显示相应的时间范围。
- **调用 `updateView(value)`**：根据当前滑块值更新可见节点。

#### 4. 更新可见节点
`updateView` 函数负责根据时间阈值筛选可见的节点。

```javascript
function updateView(threshold) {
    const visibleNodes = new Set();
    
    // 一遍遍历：找出时间小于阈值的节点(表示更近的时间)
    root.descendants().forEach(d => {
        const time = parseTime(d.data.time);
        if (time === 0 || time <= threshold) {
            visibleNodes.add(d.id);
            // 将必要的祖先节点加入可见集合
            let ancestor = d.parent;
            while (ancestor) {
                visibleNodes.add(ancestor.id);
                ancestor = ancestor.parent;
            }
        }
    });

    // 更新连接线和节点显示
    g.selectAll(".link")
        .style("display", d => {
            return (visibleNodes.has(d.source.id) && visibleNodes.has(d.target.id)) ? "block" : "none";
        });

    g.selectAll(".node")
        .style("display", d => {
            return visibleNodes.has(d.id) ? "block" : "none";
        });
}
```

- **可见节点集合**：使用 `Set` 存储可见节点的 ID。
- **遍历节点**：遍历所有节点，使用 `parseTime` 函数解析时间，并判断是否小于或等于阈值。
- **祖先节点处理**：如果节点可见，则将其所有祖先节点也加入可见集合，以确保树形结构的完整性。
- **更新显示**：根据 `visibleNodes` 集合更新连接线和节点的显示状态。

#### 5. 时间解析函数
`parseTime` 函数用于将时间字符串转换为统一的数值格式，以便进行比较。

```javascript
function parseTime(timeStr) {
    if (!timeStr) return 0;
    
    // 处理"亿年前"格式
    let match = timeStr.match(/(\d+(?:\.\d+)?)\s*亿年前/);
    if (match) {
        return parseFloat(match[1]) * 10000; // 转换为万年单位
    }
    
    // 处理"万年前"格式
    match = timeStr.match(/(\d+(?:\.\d+)?)\s*万年前/);
    if (match) {
        return parseFloat(match[1]); // 已经是万年单位
    }
    
    // 处理"百万年前"格式
    match = timeStr.match(/(\d+(?:\.\d+)?)\s*百万年前/);
    if (match) {
        return parseFloat(match[1]) * 100; // 转换为万年单位
    }
    
    return 0;
}
```

- **时间格式处理**：根据不同的时间格式（亿年前、万年前、百万年前）进行解析，并统一转换为万年单位。

### 总结
时间线筛选功能通过滑块输入和事件监听实现，用户可以通过调整滑块选择时间范围。根据选择的时间，系统会动态更新可见节点，确保用户能够直观地查看不同时间段的节点信息。通过解析时间字符串并更新节点显示，增强了数据的可视化效果。

# 其他页面-无

